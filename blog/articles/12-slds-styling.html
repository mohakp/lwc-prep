<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>12. Styling with SLDS ‚Äî LWC.guide</title>
  <meta name="description" content="A first-principles deep-dive into SLDS styling for LWC: CSS specificity, design tokens, utility classes, styling hooks (--slds-c-* and --slds-g-*), SLDS 2.0 changes, component-scoped CSS, and real-world layout patterns.">
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'; connect-src 'none'; frame-ancestors 'none';">
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta name="referrer" content="strict-origin-when-cross-origin">
  <link rel="canonical" href="https://mohakp.github.io/lwc-prep/articles/12-slds-styling.html">
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="../assets/prism.min.css">
</head>
<body>

  <!-- ================================================================
       SITE HEADER
       ================================================================ -->
  <header class="site-header" role="banner">
    <div class="site-header__inner">
      <a href="../index.html" class="site-logo" aria-label="LWC.guide Home">
        LWC<span>.</span>guide
      </a>
      <nav class="site-nav" aria-label="Site navigation">
        <button
          class="theme-toggle"
          id="themeToggle"
          aria-label="Toggle dark/light mode"
          title="Toggle dark/light mode"
        >
          <span class="icon-moon" aria-hidden="true">üåô</span>
          <span class="icon-sun"  aria-hidden="true">‚òÄÔ∏è</span>
          <span id="themeLabel">Dark</span>
        </button>
      </nav>
    </div>
  </header>

  <!-- ================================================================
       ARTICLE LAYOUT (sidebar TOC + main content)
       ================================================================ -->
  <div class="article-page">

    <!-- ----- Sticky TOC Sidebar ----- -->
    <aside class="toc-sidebar" aria-label="Table of contents">
      <nav class="toc-sidebar__inner">
        <div class="toc-sidebar__title">Contents</div>
        <ul class="toc-list" id="tocList">
          <li><a href="#hook">1. The Cascade Problem at Scale</a></li>
          <li><a href="#design-tokens">2. Design Tokens</a></li>
          <li class="level-3"><a href="#what-is-a-token">What Is a Token?</a></li>
          <li class="level-3"><a href="#token-categories">Token Categories</a></li>
          <li class="level-3"><a href="#using-tokens">Using Tokens in LWC CSS</a></li>
          <li><a href="#component-scoped-css">3. Component-Scoped CSS</a></li>
          <li class="level-3"><a href="#host-selector">The :host Selector</a></li>
          <li class="level-3"><a href="#compile-time-scoping">Compile-Time Scope Attributes</a></li>
          <li class="level-3"><a href="#at-import">@import for Shared Styles</a></li>
          <li><a href="#utility-classes">4. SLDS Utility Classes</a></li>
          <li class="level-3"><a href="#grid-system">Grid &amp; Flexbox Layout</a></li>
          <li class="level-3"><a href="#spacing">Spacing Utilities</a></li>
          <li class="level-3"><a href="#typography">Typography &amp; Text</a></li>
          <li class="level-3"><a href="#responsive">Responsive Breakpoints</a></li>
          <li><a href="#blueprint-vs-base">5. Blueprint vs Base Components</a></li>
          <li><a href="#dont-override">6. Why Not to Override SLDS Classes</a></li>
          <li class="level-3"><a href="#specificity-wars">Specificity Wars</a></li>
          <li class="level-3"><a href="#upgrade-fragility">Upgrade Fragility</a></li>
          <li class="level-3"><a href="#shadow-dom-block">Shadow DOM Blocks You Anyway</a></li>
          <li><a href="#css-custom-props">7. CSS Custom Properties &amp; Shadow DOM</a></li>
          <li class="level-3"><a href="#inheritance-pierces">Custom Properties Pierce Shadow Boundaries</a></li>
          <li><a href="#styling-hooks">8. SLDS Styling Hooks</a></li>
          <li class="level-3"><a href="#component-hooks">Component Hooks (--slds-c-*)</a></li>
          <li class="level-3"><a href="#global-hooks">Global Hooks (--slds-g-*)</a></li>
          <li class="level-3"><a href="#custom-component-hooks">Exposing Hooks from Your Component</a></li>
          <li><a href="#slds2">9. SLDS 2.0 Architecture</a></li>
          <li class="level-3"><a href="#slds2-what-changed">What Changed</a></li>
          <li class="level-3"><a href="#slds2-dark-mode">Dark Mode Support</a></li>
          <li class="level-3"><a href="#slds2-hooks-status">Styling Hooks in SLDS 2</a></li>
          <li class="level-3"><a href="#slds2-migration">Migration Considerations</a></li>
          <li><a href="#experience-cloud">10. Theming in Experience Cloud</a></li>
          <li><a href="#layout-patterns">11. Common Layout Patterns</a></li>
          <li class="level-3"><a href="#card-pattern">Card Layout</a></li>
          <li class="level-3"><a href="#form-pattern">Form Layout</a></li>
          <li class="level-3"><a href="#modal-pattern">Modal Pattern</a></li>
          <li><a href="#pitfalls">12. Pitfall Catalogue</a></li>
          <li><a href="#p3-insight">13. Expert Insight</a></li>
          <li><a href="#recall">14. Quick Recall Card</a></li>
        </ul>
      </nav>
    </aside>

    <!-- ----- Main Article Content ----- -->
    <main class="article-main" id="articleMain">

      <!-- Article Header -->
      <header class="article-header">
        <div class="article-breadcrumb">
          <a href="../index.html">‚Üê All Articles</a>
        </div>
        <div class="article-number">Article 12</div>
        <h1>Styling with SLDS</h1>
        <div class="article-meta">
          <span>‚è± 22 min read</span>
          <span class="tags">
            <span class="tag">#styling</span>
            <span class="tag">#slds</span>
            <span class="tag">#css</span>
          </span>
        </div>
        <button
          class="mark-read-btn"
          id="markReadBtn"
          data-article-id="12"
          aria-pressed="false"
        >Mark as Read</button>
      </header>

      <!-- ============================================================
           SECTION 1 ‚Äî HOOK
           ============================================================ -->
      <section id="hook">
        <h2>1. The Cascade Problem at Scale</h2>
        <p>
          Imagine you are on a team of 30 engineers building a Salesforce org with 200 custom
          components. Each engineer has been writing their own CSS. Some use <code>.title</code>,
          some use <code>.card-title</code>, some use <code>h2 { font-size: 18px; }</code>.
          Components share a global DOM. Any style that leaks out of one component can silently
          overwrite the styles of another. You end up debugging at 11 PM, wondering why the
          Account page's title font is 14px and you can't figure out who set it.
        </p>
        <p>
          This is the CSS global scope problem ‚Äî the same problem that haunted large web apps for
          a decade before CSS-in-JS and Shadow DOM emerged as solutions. SLDS (Salesforce Lightning
          Design System) was built specifically to solve this at the design-system level, and LWC's
          CSS scoping was built to enforce it at the component level.
        </p>
        <p>
          To style LWC components correctly you need three things working in concert:
        </p>
        <ol>
          <li><strong>Design tokens</strong> ‚Äî semantic, platform-maintained values for colour,
          spacing, and typography that you reference instead of hardcoding.</li>
          <li><strong>SLDS utility classes and component blueprints</strong> ‚Äî the pre-built layout
          primitives and component CSS that ships with Salesforce.</li>
          <li><strong>CSS custom properties (SLDS styling hooks)</strong> ‚Äî the only
          standards-compliant mechanism for safely customising how base components look, without
          breaking on upgrades.</li>
        </ol>
        <p>
          This article builds each concept from first principles, connects them to LWC's
          Shadow DOM model, and shows the exact patterns a expert architect must know ‚Äî including the
          critical changes introduced by SLDS 2.0 in Spring '25.
        </p>
      </section>

      <!-- ============================================================
           SECTION 2 ‚Äî DESIGN TOKENS
           ============================================================ -->
      <section id="design-tokens">
        <h2>2. Design Tokens</h2>

        <h3 id="what-is-a-token">What Is a Token?</h3>
        <p>
          A design token is a named, platform-maintained constant that encodes a design decision.
          Instead of writing <code>color: #0176d3</code> (a raw hex value nobody recognises at
          a glance), you write <code>var(--slds-g-color-brand-base-50)</code> ‚Äî a name that carries
          semantic meaning: "the 50th shade of the brand primary colour."
        </p>
        <p>
          The benefit is not just readability. When Salesforce releases a design system update and
          the brand blue shifts from <code>#0176d3</code> to <code>#0070d2</code>, every component
          that uses the token gets the update for free. Components that hardcoded the hex value do
          not.
        </p>
        <p>
          At their implementation level, design tokens in SLDS are <em>CSS custom properties</em>
          ‚Äî the native browser feature introduced in CSS Variables (now universally supported).
          They are defined on the <code>:root</code> element (or in a Salesforce-controlled
          stylesheet), and your component CSS inherits them through the normal CSS inheritance
          mechanism.
        </p>

        <h3 id="token-categories">Token Categories</h3>
        <p>SLDS tokens fall into two main tiers:</p>

        <table>
          <thead>
            <tr>
              <th>Tier</th>
              <th>Prefix</th>
              <th>Purpose</th>
              <th>Example</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Global Color</td>
              <td><code>--slds-g-color-*</code></td>
              <td>Semantic brand and neutral palette</td>
              <td><code>--slds-g-color-brand-base-50</code></td>
            </tr>
            <tr>
              <td>Global Spacing</td>
              <td><code>--slds-g-spacing-*</code></td>
              <td>Standardised margin/padding values</td>
              <td><code>--slds-g-spacing-medium</code></td>
            </tr>
            <tr>
              <td>Global Font</td>
              <td><code>--slds-g-font-*</code></td>
              <td>Font family, sizes, weight</td>
              <td><code>--slds-g-font-scale-3</code></td>
            </tr>
            <tr>
              <td>Component Hook</td>
              <td><code>--slds-c-*</code></td>
              <td>Per-component customisation points</td>
              <td><code>--slds-c-button-color-border</code></td>
            </tr>
          </tbody>
        </table>

        <p>
          The older SLDS 1 design token system also exposed tokens via
          <code>@salesforce/featureFlag</code> imports or as named CSS classes. SLDS 2 formalises
          everything under CSS custom properties, making the system more consistent and
          web-standards-aligned.
        </p>

        <h3 id="using-tokens">Using Tokens in LWC CSS</h3>
        <p>
          You access design tokens directly in your component's <code>.css</code> file using the
          standard <code>var()</code> function. No import is needed ‚Äî they are inherited from the
          platform's root styles:
        </p>
        <pre><code class="language-css">/* myComponent.css */

.card-title {
  /* Use a global font token instead of hardcoding */
  font-size: var(--slds-g-font-scale-3);
  color: var(--slds-g-color-neutral-base-10);
}

.action-button {
  /* Use a brand colour token */
  background-color: var(--slds-g-color-brand-base-50);
  /* Always provide a fallback for older environments */
  background-color: var(--slds-g-color-brand-base-50, #0176d3);
}</code></pre>

        <div class="callout callout--insight">
          <div class="callout__header" role="button" tabindex="0" aria-expanded="true">
            <span class="callout__icon">üí°</span>
            <span class="callout__title">Always Provide Fallbacks</span>
            <span class="callout__toggle" aria-hidden="true">‚ñº</span>
          </div>
          <div class="callout__body">
            <p>
              CSS custom properties silently produce an invalid value if the token is undefined,
              which usually renders as the browser's default (often black or transparent). The
              <code>var(--token, fallback)</code> syntax ensures your component degrades
              gracefully if the token is missing ‚Äî for example, when rendering in a Jest test
              environment that does not inject SLDS.
            </p>
          </div>
        </div>
      </section>

      <!-- ============================================================
           SECTION 3 ‚Äî COMPONENT-SCOPED CSS
           ============================================================ -->
      <section id="component-scoped-css">
        <h2>3. Component-Scoped CSS</h2>
        <p>
          Every LWC component can have a <code>componentName.css</code> file co-located in its
          bundle. The styles defined in that file are <strong>automatically scoped</strong> to
          that component ‚Äî they cannot accidentally bleed into a child component or the global
          page. This is enforced by LWC's Shadow DOM (or Synthetic Shadow DOM) at runtime, but
          it is also baked in at compile time.
        </p>

        <h3 id="host-selector">The <code>:host</code> Selector</h3>
        <p>
          Inside a Shadow DOM component, the <em>shadow host</em> is the custom element tag itself
          (e.g., <code>&lt;c-my-card&gt;</code>). The <code>:host</code> CSS selector targets this
          element from inside its own shadow root. It is the only way to style the outermost
          element of a component from within its own CSS file.
        </p>
        <pre><code class="language-css">/* myCard.css */

/* Style the host element itself ‚Äî acts like styling <c-my-card> from within */
:host {
  display: block;          /* Custom elements are inline by default! */
  margin-bottom: var(--slds-g-spacing-medium, 1rem);
}

/* Conditional :host styling based on an attribute */
:host([variant="compact"]) {
  padding: var(--slds-g-spacing-x-small, 0.5rem);
}</code></pre>

        <div class="callout callout--warning">
          <div class="callout__header" role="button" tabindex="0" aria-expanded="true">
            <span class="callout__icon">‚ö†Ô∏è</span>
            <span class="callout__title">Custom Elements Are Inline by Default</span>
            <span class="callout__toggle" aria-hidden="true">‚ñº</span>
          </div>
          <div class="callout__body">
            <p>
              Every LWC component is a custom element. Custom elements have
              <code>display: inline</code> by default (the browser default for unknown elements).
              This surprises most developers who expect block layout. Always set
              <code>:host { display: block; }</code> (or <code>display: flex</code>,
              <code>display: grid</code> etc.) unless you specifically need inline behaviour.
              Missing this is the root cause of countless "why is my component squished" bugs.
            </p>
          </div>
        </div>

        <h3 id="compile-time-scoping">Compile-Time Scope Attributes</h3>
        <p>
          LWC's compiler generates a unique data attribute (like <code>data-lwc-host-abc123</code>)
          for each component bundle at build time. This attribute is added to every HTML element
          inside the component's template, and every CSS selector in the component's stylesheet
          is automatically rewritten by the compiler to include this attribute as an additional
          condition. This means the CSS rule:
        </p>
        <pre><code class="language-css">/* What you write */
.my-title { font-weight: bold; }

/* What the compiler generates internally */
.my-title[data-lwc-host-abc123] { font-weight: bold; }</code></pre>
        <p>
          No element outside this component will ever have the <code>data-lwc-host-abc123</code>
          attribute, so the style cannot leak. This compile-time transform is what makes LWC CSS
          scoping reliable even in the Synthetic Shadow DOM mode used in Salesforce orgs prior to
          native Shadow DOM adoption.
        </p>
        <p>
          The practical implication: you can freely use class names like <code>.title</code>,
          <code>.container</code>, or <code>.button</code> inside your component CSS without
          worrying about conflicts with other components that use the same names.
        </p>

        <h3 id="at-import">@import for Shared Styles</h3>
        <p>
          LWC supports <code>@import</code> in CSS files, but only for importing from another
          LWC module's CSS file ‚Äî not from arbitrary URLs (CSP blocks those). This lets you
          create a shared utility CSS file as a non-component module:
        </p>
        <pre><code class="language-css">/* myComponent.css ‚Äî import a shared LWC utility CSS module */
@import "c/sharedStyles";

/* Now the rules from c/sharedStyles/sharedStyles.css are available,
   still scoped to this component */
.my-section {
  padding: var(--shared-section-padding);
}</code></pre>

        <div class="callout callout--insight">
          <div class="callout__header" role="button" tabindex="0" aria-expanded="true">
            <span class="callout__icon">üí°</span>
            <span class="callout__title">@import Applies Scoping</span>
            <span class="callout__toggle" aria-hidden="true">‚ñº</span>
          </div>
          <div class="callout__body">
            <p>
              When you <code>@import</code> a CSS module, LWC applies the importing component's
              scope attribute to those rules too. The imported styles are scoped to the importing
              component, not to the source module. This means the shared CSS file is not a global
              stylesheet ‚Äî each component that imports it gets its own scoped copy.
            </p>
          </div>
        </div>
      </section>

      <!-- ============================================================
           SECTION 4 ‚Äî UTILITY CLASSES
           ============================================================ -->
      <section id="utility-classes">
        <h2>4. SLDS Utility Classes</h2>
        <p>
          SLDS ships with a large library of utility classes that can be applied directly to
          HTML elements in your component templates. Unlike the compiled CSS approach, these classes
          are applied in the template itself and are served by Salesforce's global SLDS stylesheet
          ‚Äî they do not need to be declared in your component's CSS file.
        </p>
        <p>
          This works because the SLDS global stylesheet is injected at the page level, outside any
          Shadow DOM boundary. In Synthetic Shadow DOM (the default in Salesforce), these classes
          can reach into component templates. In native Shadow DOM this is more restricted, but
          base LWC components handle this internally.
        </p>

        <h3 id="grid-system">Grid &amp; Flexbox Layout</h3>
        <p>
          SLDS uses a 12-column grid system built on flexbox. The core classes are:
        </p>
        <pre><code class="language-html">&lt;!-- 12-column flexbox grid --&gt;
&lt;div class="slds-grid slds-wrap"&gt;

  &lt;!-- Responsive column: full width on small, 6/12 on medium, 4/12 on large --&gt;
  &lt;div class="slds-col slds-size_1-of-1 slds-medium-size_6-of-12 slds-large-size_4-of-12"&gt;
    Column A
  &lt;/div&gt;

  &lt;div class="slds-col slds-size_1-of-1 slds-medium-size_6-of-12 slds-large-size_4-of-12"&gt;
    Column B
  &lt;/div&gt;

  &lt;div class="slds-col slds-size_1-of-1 slds-medium-size_1-of-1 slds-large-size_4-of-12"&gt;
    Column C
  &lt;/div&gt;
&lt;/div&gt;</code></pre>

        <p>Key grid modifier classes:</p>
        <table>
          <thead>
            <tr><th>Class</th><th>Effect</th></tr>
          </thead>
          <tbody>
            <tr><td><code>slds-grid</code></td><td>Creates a <code>display: flex</code> row container</td></tr>
            <tr><td><code>slds-wrap</code></td><td>Allows columns to wrap to the next line</td></tr>
            <tr><td><code>slds-grid_align-center</code></td><td><code>justify-content: center</code></td></tr>
            <tr><td><code>slds-grid_align-spread</code></td><td><code>justify-content: space-between</code></td></tr>
            <tr><td><code>slds-grid_vertical-align-center</code></td><td><code>align-items: center</code></td></tr>
            <tr><td><code>slds-col_bump-left</code></td><td>Pushes a column to the far right via <code>margin-left: auto</code></td></tr>
          </tbody>
        </table>

        <h3 id="spacing">Spacing Utilities</h3>
        <p>
          SLDS spacing utilities follow a predictable naming pattern:
          <code>slds-{m|p}-{side}-{size}</code>.
        </p>
        <pre><code class="language-html">&lt;!-- Margin: all sides, medium size --&gt;
&lt;div class="slds-m-around_medium"&gt; ... &lt;/div&gt;

&lt;!-- Padding: vertical only, small --&gt;
&lt;div class="slds-p-vertical_small"&gt; ... &lt;/div&gt;

&lt;!-- Margin top only, large --&gt;
&lt;div class="slds-m-top_large"&gt; ... &lt;/div&gt;

&lt;!-- Remove margin on both sides (often used inside grids) --&gt;
&lt;div class="slds-m-horizontal_none"&gt; ... &lt;/div&gt;</code></pre>

        <p>Size scale: <code>xxx-small</code>, <code>xx-small</code>, <code>x-small</code>,
        <code>small</code>, <code>medium</code>, <code>large</code>, <code>x-large</code>,
        <code>xx-large</code>.</p>

        <h3 id="typography">Typography &amp; Text</h3>
        <pre><code class="language-html">&lt;!-- Truncate text with ellipsis in a single line --&gt;
&lt;p class="slds-truncate" title="The full text shown on hover"&gt;Very long text...&lt;/p&gt;

&lt;!-- Text alignment --&gt;
&lt;p class="slds-text-align_center"&gt;Centred&lt;/p&gt;
&lt;p class="slds-text-align_right"&gt;Right-aligned&lt;/p&gt;

&lt;!-- Semantic text styles --&gt;
&lt;p class="slds-text-heading_medium"&gt;Section heading&lt;/p&gt;
&lt;p class="slds-text-title_caps"&gt;Label text&lt;/p&gt;
&lt;p class="slds-text-color_weak"&gt;Muted descriptive text&lt;/p&gt;
&lt;p class="slds-text-color_error"&gt;Validation error message&lt;/p&gt;</code></pre>

        <h3 id="responsive">Responsive Breakpoints</h3>
        <p>
          SLDS defines three breakpoints with the prefixes <code>slds-small-*</code>,
          <code>slds-medium-*</code>, and <code>slds-large-*</code> for column sizing, and
          <code>slds-show_*</code> / <code>slds-hide_*</code> for visibility:
        </p>
        <pre><code class="language-html">&lt;!-- Only visible on small screens (mobile) --&gt;
&lt;div class="slds-show_small slds-hide_medium-up"&gt;Mobile-only content&lt;/div&gt;

&lt;!-- Only visible on medium+ screens (tablet and up) --&gt;
&lt;div class="slds-hide_small slds-show_medium-up"&gt;Tablet and desktop content&lt;/div&gt;</code></pre>

        <div class="callout callout--warning">
          <div class="callout__header" role="button" tabindex="0" aria-expanded="true">
            <span class="callout__icon">‚ö†Ô∏è</span>
            <span class="callout__title">slds-show / slds-hide Use display:none</span>
            <span class="callout__toggle" aria-hidden="true">‚ñº</span>
          </div>
          <div class="callout__body">
            <p>
              These visibility classes use CSS <code>display: none</code>, not
              <code>lwc:if</code> conditional rendering. The DOM element is always created and
              always runs its JavaScript (including <code>connectedCallback</code>,
              <code>@wire</code> calls, etc.) ‚Äî it is merely hidden visually. For true conditional
              rendering (where the component should not mount or fetch data on mobile), use
              <code>lwc:if</code> instead. Only use the CSS visibility classes when the component
              needs to retain state while visually hidden.
            </p>
          </div>
        </div>
      </section>

      <!-- ============================================================
           SECTION 5 ‚Äî BLUEPRINT VS BASE COMPONENTS
           ============================================================ -->
      <section id="blueprint-vs-base">
        <h2>5. Blueprint vs Base Components</h2>
        <p>
          SLDS has two distinct layers that developers frequently confuse:
        </p>
        <table>
          <thead>
            <tr>
              <th>Layer</th>
              <th>What It Is</th>
              <th>How You Use It</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><strong>SLDS Blueprint</strong></td>
              <td>Raw HTML + CSS markup patterns documented on the SLDS website. No JavaScript. Just structure and styles.</td>
              <td>Copy the HTML structure into your template and add the listed CSS classes.</td>
            </tr>
            <tr>
              <td><strong>Base Lightning Components</strong></td>
              <td>Pre-built LWC components (<code>lightning-button</code>, <code>lightning-input</code>, <code>lightning-datatable</code>, etc.) that implement SLDS blueprints AND add JavaScript behaviour, accessibility, and ARIA management.</td>
              <td>Use directly in templates as <code>&lt;lightning-button&gt;</code> etc. No CSS needed.</td>
            </tr>
          </tbody>
        </table>
        <p>
          The practical rule: always prefer <strong>base components</strong> over copying blueprint
          markup. Base components handle accessibility (ARIA attributes, keyboard navigation, focus
          management), responsive behaviour, and are maintained by Salesforce ‚Äî they get security
          and accessibility patches automatically. Only fall back to blueprint markup when you need
          a UI pattern that has no base component equivalent.
        </p>
        <pre><code class="language-html">&lt;!-- ‚úÖ Preferred: base component handles everything --&gt;
&lt;lightning-button
  label="Save"
  variant="brand"
  onclick={handleSave}
&gt;&lt;/lightning-button&gt;

&lt;!-- ‚ùå Avoid unless necessary: blueprint markup you own the accessibility for --&gt;
&lt;button class="slds-button slds-button_brand" onclick={handleSave}&gt;Save&lt;/button&gt;</code></pre>
      </section>

      <!-- ============================================================
           SECTION 6 ‚Äî WHY NOT TO OVERRIDE SLDS CLASSES
           ============================================================ -->
      <section id="dont-override">
        <h2>6. Why Not to Override SLDS Classes Directly</h2>
        <p>
          One of the most common LWC mistakes is writing CSS that directly targets SLDS class
          names. Let's explore exactly why this is dangerous.
        </p>

        <h3 id="specificity-wars">Specificity Wars</h3>
        <p>
          When you write <code>.slds-button { background: red; }</code> in your component's
          stylesheet, you are creating a selector that competes with Salesforce's own SLDS
          stylesheet. If SLDS uses a more specific selector for the same property (which it
          frequently does), your override silently loses with no error. Worse, you may win the
          specificity battle today but lose it after a Salesforce release upgrades the SLDS
          stylesheet with higher-specificity rules.
        </p>
        <pre><code class="language-css">/* ‚ùå Fragile: directly targeting an SLDS class */
.slds-button {
  background-color: purple; /* May or may not win vs SLDS specificity */
}

/* ‚ùå Also fragile: using !important to force a win */
.slds-button {
  background-color: purple !important; /* May conflict with legitimate !important in SLDS */
}</code></pre>

        <h3 id="upgrade-fragility">Upgrade Fragility</h3>
        <p>
          SLDS class names, HTML structure, and internal CSS are not considered public API by
          Salesforce. They can change between releases without notice. If your CSS depends on an
          SLDS class's internal structure (e.g., <code>.slds-button .slds-button__icon</code>),
          a future release that renames or restructures the internal SLDS markup silently breaks
          your component ‚Äî and you won't know until your users report it after a major release.
        </p>

        <h3 id="shadow-dom-block">Shadow DOM Blocks You Anyway</h3>
        <p>
          Base Lightning Components (<code>lightning-button</code>, <code>lightning-input</code>)
          are LWC components with their own Shadow DOM. Your component's CSS <strong>cannot
          penetrate into their Shadow DOM</strong>. Even if you write
          <code>.slds-button { color: red; }</code> in your component's stylesheet, that rule
          will have zero effect on a <code>&lt;lightning-button&gt;</code> rendered inside your
          template ‚Äî the Shadow DOM boundary blocks it.
        </p>
        <p>
          The only way to customise a base component's appearance is through the styling hooks
          it intentionally exposes. Which brings us to the right approach.
        </p>
      </section>

      <!-- ============================================================
           SECTION 7 ‚Äî CSS CUSTOM PROPERTIES & SHADOW DOM
           ============================================================ -->
      <section id="css-custom-props">
        <h2>7. CSS Custom Properties &amp; Shadow DOM</h2>
        <p>
          To understand styling hooks, you must first understand one critical behaviour of CSS
          custom properties with respect to Shadow DOM: <strong>custom properties inherit across
          shadow boundaries</strong>. This is the single exception to Shadow DOM's style
          encapsulation rule.
        </p>

        <h3 id="inheritance-pierces">Custom Properties Pierce Shadow Boundaries</h3>
        <p>
          Normal CSS rules (selectors, class-based rules) cannot cross from a parent component
          into a child's Shadow DOM. But CSS custom property values propagate through CSS
          inheritance ‚Äî and inheritance does cross Shadow DOM boundaries. This is by spec design,
          and it is what makes SLDS styling hooks possible.
        </p>
        <p>
          Here is the mechanism in plain terms:
        </p>
        <ol>
          <li>You define a custom property on an ancestor element (or <code>:host</code>):
          <code>--my-color: blue;</code></li>
          <li>A descendant element inside a child component's Shadow DOM reads that property:
          <code>color: var(--my-color);</code></li>
          <li>Because CSS inheritance crosses Shadow DOM boundaries, the child component's
          element receives the value <code>blue</code>.</li>
        </ol>
        <pre><code class="language-css">/* Parent component CSS ‚Äî sets a custom property */
:host {
  --slds-c-button-color-background: #8a2be2; /* BlueViolet */
}

/* Inside lightning-button's Shadow DOM (simplified) ‚Äî reads the property */
/* .slds-button { background-color: var(--slds-c-button-color-background); } */</code></pre>
        <p>
          You never write the second block ‚Äî Salesforce's <code>lightning-button</code>
          implementation already does. You only need to set the custom property value from the
          outside, and the component picks it up.
        </p>
      </section>

      <!-- ============================================================
           SECTION 8 ‚Äî STYLING HOOKS
           ============================================================ -->
      <section id="styling-hooks">
        <h2>8. SLDS Styling Hooks</h2>
        <p>
          SLDS Styling Hooks are the formally exposed set of CSS custom properties that
          Salesforce commits to supporting across releases. They are documented in the SLDS
          component blueprint pages and come in two flavours.
        </p>

        <h3 id="component-hooks">Component Hooks (<code>--slds-c-*</code>)</h3>
        <p>
          Component styling hooks (<code>--slds-c-{component}-{property}</code>) let you
          customise a specific property of a specific base component without affecting all other
          instances of that component type across the app. They are scoped to the component that
          consumes them.
        </p>
        <pre><code class="language-css">/* myComponent.css */

/* Customise lightning-button only within THIS component's scope */
:host {
  /* Change border of buttons inside my component */
  --slds-c-button-color-border: #8a2be2;
  /* Make the button text bold */
  --slds-c-button-text-font-weight: 700;
  /* Change border radius for a pill-shaped button */
  --slds-c-button-radius-border: 100px;
}</code></pre>
        <p>
          Every base component documents its supported styling hooks on its blueprint page.
          For example, <code>lightning-button</code>'s hooks are listed as
          <code>--slds-c-button-*</code>. There are hooks for colour, border, sizing, spacing,
          typography, and shadow.
        </p>

        <div class="callout callout--warning">
          <div class="callout__header" role="button" tabindex="0" aria-expanded="true">
            <span class="callout__icon">‚ö†Ô∏è</span>
            <span class="callout__title">Component Hooks Are SLDS 1 Only (as of Summer '25)</span>
            <span class="callout__toggle" aria-hidden="true">‚ñº</span>
          </div>
          <div class="callout__body">
            <p>
              As of Summer '25, <code>--slds-c-*</code> component styling hooks are available
              only in <strong>SLDS 1</strong>. SLDS 2 does not yet support them. If your org is
              running SLDS 2 themes (enabled via Salesforce's Theming settings), component styling
              hooks will have no effect. Salesforce is working to bring them to SLDS 2, but until
              then: if you rely on <code>--slds-c-*</code> hooks, keep your org on SLDS 1 themes.
              See: <a href="https://developer.salesforce.com/docs/platform/lwc/guide/create-components-css-slds1-slds2.html" target="_blank" rel="noopener noreferrer">Compare SLDS Versions</a>.
            </p>
          </div>
        </div>

        <h3 id="global-hooks">Global Hooks (<code>--slds-g-*</code>)</h3>
        <p>
          Global styling hooks (<code>--slds-g-{category}-{name}</code>) are predefined values
          shared globally across the entire org. Changing a global hook affects every component
          that reads it ‚Äî this is how Salesforce implements org-wide theming (e.g., setting a
          different brand colour in Setup ‚Üí Themes and Branding).
        </p>
        <p>
          Global hooks are read-only for custom component developers in the sense that you should
          <em>consume</em> them (via <code>var()</code>) rather than override them. Overriding
          global hooks from within a component is technically possible but a bad practice ‚Äî it
          fights the platform's theming system.
        </p>
        <pre><code class="language-css">/* ‚úÖ Correct: CONSUMING a global hook */
.my-brand-badge {
  background-color: var(--slds-g-color-brand-base-50, #0176d3);
  color: var(--slds-g-color-neutral-base-100, #ffffff);
}

/* ‚ùå Bad practice: OVERRIDING a global hook from within a component */
:root {
  --slds-g-color-brand-base-50: purple; /* Affects the entire org! */
}</code></pre>

        <h3 id="custom-component-hooks">Exposing Styling Hooks from Your Own Component</h3>
        <p>
          You can expose your own CSS custom properties as styling hooks on components you build,
          allowing parent components (or admins in App Builder via CSS) to customise your
          component without forking it.
        </p>
        <pre><code class="language-css">/* myCard.css ‚Äî consumer of externally set hooks */

:host {
  display: block;
}

.card-container {
  /* Read a custom hook; fall back to an SLDS global token if not set */
  background-color: var(--my-card-bg-color, var(--slds-g-color-neutral-base-95, #f3f3f3));
  border-radius: var(--my-card-border-radius, 4px);
  padding: var(--my-card-padding, var(--slds-g-spacing-medium, 1rem));
}</code></pre>
        <pre><code class="language-css">/* parentComponent.css ‚Äî supplies the hook values */

c-my-card {
  --my-card-bg-color: #e8f4fd;
  --my-card-border-radius: 8px;
}</code></pre>
        <p>
          The parent sets the custom properties on the <code>c-my-card</code> element. CSS
          inheritance carries those values into <code>myCard</code>'s Shadow DOM, where
          <code>var(--my-card-bg-color)</code> picks them up.
        </p>

        <div class="callout callout--insight">
          <div class="callout__header" role="button" tabindex="0" aria-expanded="true">
            <span class="callout__icon">üí°</span>
            <span class="callout__title">Document Your Component's Hooks</span>
            <span class="callout__toggle" aria-hidden="true">‚ñº</span>
          </div>
          <div class="callout__body">
            <p>
              If you are building a reusable component library inside your org, document every
              CSS custom property your component accepts ‚Äî its name, what it controls, its default
              value, and its fallback. This is exactly what the SLDS team does for base components.
              Without documentation, consumers won't know what they can customise without reading
              your CSS source.
            </p>
          </div>
        </div>
      </section>

      <!-- ============================================================
           SECTION 9 ‚Äî SLDS 2.0
           ============================================================ -->
      <section id="slds2">
        <h2>9. SLDS 2.0 Architecture</h2>
        <p>
          SLDS 2 (also called the "Cosmos" design system) was introduced in Spring '25 as a
          significant rearchitecture of the design system, moving it fully onto CSS custom
          properties and introducing proper dark mode support. It is opt-in and controlled by
          your org's Theming settings.
        </p>

        <h3 id="slds2-what-changed">What Changed</h3>
        <table>
          <thead>
            <tr>
              <th>Aspect</th>
              <th>SLDS 1</th>
              <th>SLDS 2</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Design token delivery</td>
              <td>Mix of CSS classes and some custom properties</td>
              <td>Fully CSS custom properties</td>
            </tr>
            <tr>
              <td>Visual language</td>
              <td>Salesforce Classic/SLDS original look</td>
              <td>"Cosmos" ‚Äî updated visual style, rounder shapes, refreshed palette</td>
            </tr>
            <tr>
              <td>Dark mode</td>
              <td>Not supported</td>
              <td>First-class support via <code>prefers-color-scheme</code> media query and Salesforce theme switcher</td>
            </tr>
            <tr>
              <td>Component hooks (<code>--slds-c-*</code>)</td>
              <td>Supported</td>
              <td>Not yet supported (as of Summer '25)</td>
            </tr>
            <tr>
              <td>Global hooks (<code>--slds-g-*</code>)</td>
              <td>Supported</td>
              <td>Supported with updated token values</td>
            </tr>
            <tr>
              <td>Base components</td>
              <td>Rendered with SLDS 1 styles</td>
              <td>Rendered with Cosmos visual styles when SLDS 2 theme is active</td>
            </tr>
          </tbody>
        </table>

        <h3 id="slds2-dark-mode">Dark Mode Support</h3>
        <p>
          SLDS 2 introduces genuine dark mode. The platform uses CSS custom properties to swap
          token values based on the active theme. When dark mode is enabled (either by the user
          preference or by the admin's org theme setting), all <code>--slds-g-color-*</code>
          tokens automatically take on their dark-mode values ‚Äî provided you reference tokens
          rather than hardcoded colours.
        </p>
        <pre><code class="language-css">/* ‚úÖ This automatically adapts to dark mode in SLDS 2 */
.my-text {
  color: var(--slds-g-color-neutral-base-10, #181818);
  background: var(--slds-g-color-neutral-base-100, #ffffff);
}

/* ‚ùå This will NOT adapt ‚Äî hardcoded values are not token-aware */
.my-text {
  color: #181818;
  background: #ffffff;
}</code></pre>

        <h3 id="slds2-hooks-status">Styling Hooks in SLDS 2 ‚Äî Current Status</h3>
        <p>
          This is the most important Expert nuance about SLDS 2: the <code>--slds-c-*</code>
          component styling hooks that work beautifully in SLDS 1 are <strong>not yet functional
          in SLDS 2</strong>. If your org admin enables SLDS 2 theming and your custom components
          use <code>--slds-c-button-*</code> hooks to brand your buttons, those customisations
          will silently disappear.
        </p>
        <p>
          The global hooks (<code>--slds-g-*</code>) do work in both versions, with updated
          values in SLDS 2. Always include fallback values when using SLDS 1 global token names
          in case their values differ in SLDS 2.
        </p>

        <h3 id="slds2-migration">Migration Considerations</h3>
        <ul>
          <li>Audit your custom CSS for hardcoded hex values and replace with
          <code>--slds-g-*</code> token references.</li>
          <li>Test your components under both the SLDS 1 and SLDS 2 themes (enable via Setup ‚Üí
          User Interface ‚Üí Themes and Branding).</li>
          <li>If you rely on <code>--slds-c-*</code> component hooks, either document this
          constraint and stay on SLDS 1, or plan to migrate those customisations when SLDS 2
          adds component hook support.</li>
          <li>Verify that your components do not break under dark mode by testing with SLDS 2
          and the dark theme active.</li>
        </ul>
      </section>

      <!-- ============================================================
           SECTION 10 ‚Äî EXPERIENCE CLOUD
           ============================================================ -->
      <section id="experience-cloud">
        <h2>10. Theming in Experience Cloud</h2>
        <p>
          Experience Cloud (formerly Community Cloud) has its own theming system that sits on
          top of SLDS. When your LWC components are deployed to an Experience Cloud site, the
          token values and hook namespaces may be different from core Salesforce.
        </p>
        <p>Key differences to know:</p>
        <ul>
          <li><strong>Theme-specific hooks:</strong> Experience Cloud uses its own CSS variable
          namespace for colours set in the Experience Builder Branding panel. These are injected
          into the site's root styles and cascade into your components, but they use different
          variable names than <code>--slds-g-*</code>. Check the Experience Cloud theming
          documentation for the exact variable names.</li>
          <li><strong>LWR (Lightning Web Runtime) sites:</strong> Newer Experience Cloud sites
          use LWR instead of Aura as the runtime. On LWR sites, native Shadow DOM may be used
          (not Synthetic Shadow), which changes how SLDS utility classes and style penetration
          work. Test your components in both runtime environments.</li>
          <li><strong>Font and spacing differences:</strong> Experience Cloud sites often apply
          a base CSS reset and font override that differs from the Salesforce core UI. Your
          components that rely on SLDS tokens will automatically adapt, but hardcoded values
          will stand out as inconsistent.</li>
          <li><strong>SLDS availability:</strong> On LWR sites, the full SLDS stylesheet may not
          be automatically injected. Components that depend on global SLDS utility classes
          (<code>slds-grid</code>, etc.) may need to include those styles locally or use the
          <code>@salesforce/resourceUrl</code> to load a local SLDS subset.</li>
        </ul>
      </section>

      <!-- ============================================================
           SECTION 11 ‚Äî LAYOUT PATTERNS
           ============================================================ -->
      <section id="layout-patterns">
        <h2>11. Common SLDS Layout Patterns</h2>

        <h3 id="card-pattern">Card Layout</h3>
        <p>
          The SLDS card blueprint is the most used layout primitive in Salesforce apps. When you
          need the base-component version, use <code>lightning-card</code> ‚Äî it handles the
          header, footer, and actions slots. When you need more control, use the blueprint:
        </p>
        <pre><code class="language-html">&lt;template&gt;
  &lt;!-- lightning-card: preferred for standard record cards --&gt;
  &lt;lightning-card title="Account Details" icon-name="standard:account"&gt;
    &lt;!-- Actions slot --&gt;
    &lt;div slot="actions"&gt;
      &lt;lightning-button label="Edit" onclick={handleEdit}&gt;&lt;/lightning-button&gt;
    &lt;/div&gt;
    &lt;!-- Body --&gt;
    &lt;div class="slds-card__body slds-card__body_inner"&gt;
      &lt;p&gt;Content goes here&lt;/p&gt;
    &lt;/div&gt;
    &lt;!-- Footer slot --&gt;
    &lt;div slot="footer"&gt;Last updated today&lt;/div&gt;
  &lt;/lightning-card&gt;
&lt;/template&gt;</code></pre>

        <h3 id="form-pattern">Form Layout</h3>
        <p>
          SLDS forms use a stacked grid to align labels and inputs consistently:
        </p>
        <pre><code class="language-html">&lt;template&gt;
  &lt;!-- For simple forms, lightning-record-edit-form handles everything --&gt;
  &lt;lightning-record-edit-form object-api-name="Contact" record-id={recordId}&gt;
    &lt;lightning-messages&gt;&lt;/lightning-messages&gt;
    &lt;div class="slds-grid slds-wrap"&gt;
      &lt;div class="slds-col slds-size_1-of-2"&gt;
        &lt;lightning-input-field field-name="FirstName"&gt;&lt;/lightning-input-field&gt;
      &lt;/div&gt;
      &lt;div class="slds-col slds-size_1-of-2"&gt;
        &lt;lightning-input-field field-name="LastName"&gt;&lt;/lightning-input-field&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;lightning-button type="submit" label="Save" variant="brand"&gt;&lt;/lightning-button&gt;
  &lt;/lightning-record-edit-form&gt;
&lt;/template&gt;</code></pre>

        <h3 id="modal-pattern">Modal Pattern</h3>
        <p>
          Salesforce provides <code>lightning-modal</code> (API v55+) as the standard modal
          pattern. It handles focus trapping, Escape key dismiss, and accessibility automatically.
          For older API versions, you can use the SLDS blueprint with manual focus management
          (see Article 16 on Accessibility for the full focus trap pattern).
        </p>
        <pre><code class="language-javascript">// Triggering a lightning-modal programmatically
import { LightningElement } from 'lwc';
import MyModal from 'c/myModal';

export default class MyPage extends LightningElement {
  async handleOpenModal() {
    const result = await MyModal.open({
      size: 'medium',
      label: 'Confirm Action',
      // Props passed to the modal component
      description: 'Are you sure you want to delete this record?'
    });

    // result is whatever the modal passes to this.close(result)
    if (result === 'confirmed') {
      this.handleDelete();
    }
  }
}</code></pre>
        <pre><code class="language-javascript">// myModal.js ‚Äî the modal component itself
import LightningModal from 'lightning/modal';
import { api } from 'lwc';

export default class MyModal extends LightningModal {
  @api description;

  handleConfirm() {
    this.close('confirmed'); // passes 'confirmed' back as the result
  }

  handleCancel() {
    this.close('cancelled');
  }
}</code></pre>
        <pre><code class="language-html">&lt;!-- myModal.html --&gt;
&lt;template&gt;
  &lt;lightning-modal-header label={label}&gt;&lt;/lightning-modal-header&gt;
  &lt;lightning-modal-body&gt;
    &lt;p&gt;{description}&lt;/p&gt;
  &lt;/lightning-modal-body&gt;
  &lt;lightning-modal-footer&gt;
    &lt;lightning-button label="Cancel" onclick={handleCancel}&gt;&lt;/lightning-button&gt;
    &lt;lightning-button
      label="Confirm"
      variant="brand"
      onclick={handleConfirm}
    &gt;&lt;/lightning-button&gt;
  &lt;/lightning-modal-footer&gt;
&lt;/template&gt;</code></pre>
      </section>

      <!-- ============================================================
           SECTION 12 ‚Äî PITFALL CATALOGUE
           ============================================================ -->
      <section id="pitfalls">
        <h2>12. Pitfall Catalogue</h2>

        <div class="callout callout--warning">
          <div class="callout__header" role="button" tabindex="0" aria-expanded="true">
            <span class="callout__icon">‚ö†Ô∏è</span>
            <span class="callout__title">Pitfall 1: Forgetting :host { display: block }</span>
            <span class="callout__toggle" aria-hidden="true">‚ñº</span>
          </div>
          <div class="callout__body">
            <p>
              Custom elements have <code>display: inline</code> by default. If you expect your
              component to take up full width or behave as a block, you must explicitly set
              <code>:host { display: block; }</code>. Forgetting this causes mysterious layout
              issues where components don't expand to fill their containers.
            </p>
            <pre><code class="language-css">/* Add to every component CSS by default */
:host {
  display: block;
}</code></pre>
          </div>
        </div>

        <div class="callout callout--warning">
          <div class="callout__header" role="button" tabindex="0" aria-expanded="true">
            <span class="callout__icon">‚ö†Ô∏è</span>
            <span class="callout__title">Pitfall 2: Targeting SLDS Internal Markup</span>
            <span class="callout__toggle" aria-hidden="true">‚ñº</span>
          </div>
          <div class="callout__body">
            <p>
              Selectors like <code>lightning-input .slds-input</code> or
              <code>lightning-button button</code> in your component's CSS will not work. Shadow
              DOM prevents your stylesheet from reaching into base component internals. Additionally,
              even if they worked today (in Synthetic Shadow), they would break when Salesforce
              migrates components to native Shadow DOM. Always use styling hooks instead.
            </p>
          </div>
        </div>

        <div class="callout callout--warning">
          <div class="callout__header" role="button" tabindex="0" aria-expanded="true">
            <span class="callout__icon">‚ö†Ô∏è</span>
            <span class="callout__title">Pitfall 3: Setting Global Hooks from Inside a Component</span>
            <span class="callout__toggle" aria-hidden="true">‚ñº</span>
          </div>
          <div class="callout__body">
            <p>
              Writing <code>:root { --slds-g-color-brand-base-50: purple; }</code> in your
              component's CSS overrides that token for the entire page ‚Äî every other component
              that reads the brand colour will show purple. This is almost never what you want.
              Global hooks should only be set by the platform (via Themes and Branding) or by a
              deliberate org-wide stylesheet. Set <code>--slds-c-*</code> component hooks from
              <code>:host</code> to scope the effect to your component only.
            </p>
          </div>
        </div>

        <div class="callout callout--warning">
          <div class="callout__header" role="button" tabindex="0" aria-expanded="true">
            <span class="callout__icon">‚ö†Ô∏è</span>
            <span class="callout__title">Pitfall 4: Hardcoding Colours Instead of Tokens</span>
            <span class="callout__toggle" aria-hidden="true">‚ñº</span>
          </div>
          <div class="callout__body">
            <p>
              Hardcoded hex values like <code>color: #0176d3</code> will not adapt to:
              (a) org-level theme changes set by admins, (b) SLDS 2 dark mode, or (c) any future
              design system update. Components that use token references adapt automatically.
              Make hardcoding a code-review violation for any Salesforce UI work.
            </p>
          </div>
        </div>

        <div class="callout callout--warning">
          <div class="callout__header" role="button" tabindex="0" aria-expanded="true">
            <span class="callout__icon">‚ö†Ô∏è</span>
            <span class="callout__title">Pitfall 5: Using slds-hide/slds-show When You Need lwc:if</span>
            <span class="callout__toggle" aria-hidden="true">‚ñº</span>
          </div>
          <div class="callout__body">
            <p>
              <code>slds-hide</code> is a visual-only toggle (<code>display: none</code>). A hidden
              component still runs its <code>connectedCallback</code>, fires <code>@wire</code>
              calls, and consumes memory. If a component should only initialise when visible (e.g.,
              a chart that fetches data), use <code>lwc:if</code> for true conditional mounting.
              Use <code>slds-hide</code> only when you intentionally want the component to stay
              mounted and retain state while visually hidden.
            </p>
          </div>
        </div>

        <div class="callout callout--warning">
          <div class="callout__header" role="button" tabindex="0" aria-expanded="true">
            <span class="callout__icon">‚ö†Ô∏è</span>
            <span class="callout__title">Pitfall 6: Using --slds-c-* Hooks in an SLDS 2 Org</span>
            <span class="callout__toggle" aria-hidden="true">‚ñº</span>
          </div>
          <div class="callout__body">
            <p>
              As of Summer '25, component styling hooks (<code>--slds-c-*</code>) do not work in
              SLDS 2 orgs. They silently have no effect. Before relying on component hooks for
              critical branding, check your org's SLDS version under Setup ‚Üí User Interface ‚Üí
              Themes and Branding. If you cannot stay on SLDS 1, you must find an alternative
              approach (e.g., wrapping the base component in a custom component that uses Light
              DOM to apply styles directly).
            </p>
          </div>
        </div>
      </section>

      <!-- ============================================================
           SECTION 13 ‚Äî EXPERT INSIGHT
           ============================================================ -->
      <section id="p3-insight">
        <h2>13. Expert Insight</h2>

        <div class="callout callout--insight">
          <div class="callout__header" role="button" tabindex="0" aria-expanded="true">
            <span class="callout__icon">üí°</span>
            <span class="callout__title">The Styling Hook Fallback Strategy</span>
            <span class="callout__toggle" aria-hidden="true">‚ñº</span>
          </div>
          <div class="callout__body">
            <p>
              Because <code>--slds-c-*</code> hooks don't work in SLDS 2, and your org may be
              migrated without warning, the safest pattern is to provide nested fallbacks that
              gracefully degrade:
            </p>
            <pre><code class="language-css">/* Three-level fallback chain */
.my-button-container lightning-button {
  /* 1st preference: SLDS 2 global token (works in SLDS 2 & 1) */
  --slds-c-button-color-background:
    var(--slds-g-color-brand-base-50,
      /* 2nd preference: SLDS 1 global token */
      var(--lwc-colorTextActionActive,
        /* 3rd preference: hardcoded safe default */
        #0176d3));
}</code></pre>
            <p>
              In practice, keep it simpler by using <code>--slds-g-*</code> tokens where
              possible, since those work in both versions.
            </p>
          </div>
        </div>

        <div class="callout callout--insight">
          <div class="callout__header" role="button" tabindex="0" aria-expanded="true">
            <span class="callout__icon">üí°</span>
            <span class="callout__title">Light DOM as the SLDS 2 Workaround</span>
            <span class="callout__toggle" aria-hidden="true">‚ñº</span>
          </div>
          <div class="callout__body">
            <p>
              Since Shadow DOM prevents your CSS from reaching into base components, and
              <code>--slds-c-*</code> hooks don't work in SLDS 2 yet, a controversial but valid
              pattern is to use <strong>Light DOM</strong> for components that need deep
              customisation of child base components. With Light DOM, the component renders
              without a Shadow root, so your CSS can directly reach in and target base component
              elements with standard CSS selectors.
            </p>
            <pre><code class="language-javascript">// lightDomCard.js
import { LightningElement } from 'lwc';

export default class LightDomCard extends LightningElement {
  static renderMode = 'light'; // Enable Light DOM
}</code></pre>
            <pre><code class="language-css">/* lightDomCard.css ‚Äî can now reach into child base components
   (use carefully; this is a double-edged sword) */
lightning-button.primary-action .slds-button {
  background-color: #8a2be2;
}
</code></pre>
            <p>
              The trade-off: Light DOM sacrifices CSS encapsulation. Your component's styles are
              no longer scoped ‚Äî they are global. Only use this pattern for heavily-themed
              wrapper components, not for general business logic components. It is explicitly a
              last resort when styling hooks don't meet your needs.
            </p>
          </div>
        </div>

        <div class="callout callout--insight">
          <div class="callout__header" role="button" tabindex="0" aria-expanded="true">
            <span class="callout__icon">üí°</span>
            <span class="callout__title">The Design Token Contract in Enterprise LWC</span>
            <span class="callout__toggle" aria-hidden="true">‚ñº</span>
          </div>
          <div class="callout__body">
            <p>
              In enterprise LWC development, a senior architect establishes a "token contract":
              a set of custom CSS properties that all components in the org consume, and whose
              values are set once in a shared "theme provider" component at the top of the
              component tree. No component hardcodes a colour ‚Äî it reads from the contract.
              The theme provider can be swapped without changing any individual component.
            </p>
            <pre><code class="language-css">/* themeProvider.css ‚Äî injected at app level */
:host {
  /* Brand tokens mapped to SLDS global tokens */
  --app-color-primary: var(--slds-g-color-brand-base-50, #0176d3);
  --app-color-secondary: var(--slds-g-color-brand-base-30, #014486);
  --app-spacing-base: var(--slds-g-spacing-medium, 1rem);
  --app-radius-card: 8px;
}

/* All child components read from --app-* not from hardcoded values */</code></pre>
            <p>
              This architecture means you can do a full rebrand by changing 10 lines in one CSS
              file, rather than hunting through 200 components.
            </p>
          </div>
        </div>

        <div class="callout callout--insight">
          <div class="callout__header" role="button" tabindex="0" aria-expanded="true">
            <span class="callout__icon">üí°</span>
            <span class="callout__title">SLDS Linter for Code Review Automation</span>
            <span class="callout__toggle" aria-hidden="true">‚ñº</span>
          </div>
          <div class="callout__body">
            <p>
              Salesforce provides the <strong>SLDS Linter</strong> ‚Äî a Stylelint plugin that
              automatically detects SLDS styling anti-patterns in your CSS. It can flag:
            </p>
            <ul>
              <li>Hardcoded colour values that should be tokens</li>
              <li>Overriding SLDS classes directly</li>
              <li>Using deprecated token names</li>
              <li>Missing <code>:host { display: block }</code></li>
            </ul>
            <p>
              Integrate it into your CI pipeline to enforce styling conventions across the team
              without relying on manual code review. See:
              <a href="https://developer.salesforce.com/docs/platform/slds-linter/guide/reference-rules.html" target="_blank" rel="noopener noreferrer">SLDS Linter Rules</a>.
            </p>
          </div>
        </div>
      </section>

      <!-- ============================================================
           SECTION 14 ‚Äî QUICK RECALL CARD
           ============================================================ -->
      <section id="recall">
        <h2>14. Quick Recall Card</h2>
        <table>
          <thead>
            <tr>
              <th>Concept</th>
              <th>Key Point</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>:host { display: block }</code></td>
              <td>Always set this ‚Äî custom elements are <code>inline</code> by default.</td>
            </tr>
            <tr>
              <td>Compile-time scoping</td>
              <td>LWC generates unique <code>data-lwc-host-*</code> attributes; CSS selectors are auto-rewritten to include them. Your CSS cannot leak out.</td>
            </tr>
            <tr>
              <td>Design tokens</td>
              <td>Named CSS custom properties (<code>--slds-g-color-brand-base-50</code>) that inherit through the cascade including across Shadow DOM.</td>
            </tr>
            <tr>
              <td>Custom properties pierce Shadow DOM</td>
              <td>Unlike normal CSS selectors, CSS custom properties inherit across Shadow DOM boundaries. This is what makes styling hooks possible.</td>
            </tr>
            <tr>
              <td><code>--slds-c-*</code> component hooks</td>
              <td>Scoped to one component instance. Defined on <code>:host</code> in the parent. <strong>SLDS 1 only</strong> as of Summer '25.</td>
            </tr>
            <tr>
              <td><code>--slds-g-*</code> global hooks</td>
              <td>Org-wide values ‚Äî consume with <code>var()</code>, don't override from a component.</td>
            </tr>
            <tr>
              <td>SLDS Blueprint vs Base Components</td>
              <td>Blueprints = HTML+CSS patterns. Base Components = LWC with JS, ARIA, keyboard nav. Always prefer base components.</td>
            </tr>
            <tr>
              <td>Don't override SLDS classes</td>
              <td>They're not public API (can change), specificity battles are unreliable, and Shadow DOM blocks cross-boundary selectors anyway.</td>
            </tr>
            <tr>
              <td>SLDS 2.0</td>
              <td>Spring '25. Fully CSS-custom-property based. Adds dark mode. Does NOT support <code>--slds-c-*</code> hooks yet.</td>
            </tr>
            <tr>
              <td><code>@import "c/module"</code></td>
              <td>Allowed in LWC CSS. Imported rules are scoped to the importing component, not global.</td>
            </tr>
            <tr>
              <td>Light DOM for deep styling</td>
              <td>Last resort when styling hooks don't suffice. Removes encapsulation ‚Äî use only for dedicated theme wrappers.</td>
            </tr>
            <tr>
              <td><code>slds-hide_*</code> vs <code>lwc:if</code></td>
              <td>CSS hide = DOM present + JS running + hidden visually. <code>lwc:if</code> = component not mounted at all. Pick based on need.</td>
            </tr>
          </tbody>
        </table>
      </section>

      <!-- References -->
      <section id="references">
        <h2>References</h2>
        <ul>
          <li><a href="https://developer.salesforce.com/docs/platform/lwc/guide/create-components-css-custom-properties.html" target="_blank" rel="noopener noreferrer">SLDS Styling Hooks ‚Äî LWC Developer Guide</a></li>
          <li><a href="https://developer.salesforce.com/docs/platform/lwc/guide/create-components-css-slds.html" target="_blank" rel="noopener noreferrer">Style with Lightning Design System ‚Äî LWC Developer Guide</a></li>
          <li><a href="https://developer.salesforce.com/docs/platform/lwc/guide/create-components-css-slds1-slds2.html" target="_blank" rel="noopener noreferrer">Compare SLDS Versions ‚Äî LWC Developer Guide</a></li>
          <li><a href="https://developer.salesforce.com/docs/platform/lwc/guide/create-components-css-styling-hooks.html" target="_blank" rel="noopener noreferrer">Create Styling Hooks for Your Components ‚Äî LWC Developer Guide</a></li>
          <li><a href="https://developer.salesforce.com/docs/platform/lwc/guide/create-components-css-design-tokens.html" target="_blank" rel="noopener noreferrer">SLDS Design Tokens ‚Äî LWC Developer Guide</a></li>
          <li><a href="https://developer.salesforce.com/docs/platform/slds-linter/guide/reference-rules.html" target="_blank" rel="noopener noreferrer">SLDS Linter Rules</a></li>
          <li><a href="https://www.lightningdesignsystem.com/2e1ef8501/p/319e5f-styling-hooks" target="_blank" rel="noopener noreferrer">Styling Hooks ‚Äî SLDS 2 Reference</a></li>
          <li><a href="https://trailhead.salesforce.com/content/learn/modules/salesforce-lightning-design-system-2-for-developers/explore-salesforce-lightning-design-system-2" target="_blank" rel="noopener noreferrer">SLDS 2 for Developers ‚Äî Trailhead</a></li>
        </ul>
      </section>

      <!-- Cross-links -->
      <section id="cross-links">
        <h2>Related Articles</h2>
        <ul>
          <li><a href="07-shadow-dom-vs-light-dom.html">Article 07 ‚Äî Shadow DOM vs Light DOM</a> ‚Äî Why Shadow DOM blocks cross-boundary selectors and when to use Light DOM.</li>
          <li><a href="03-component-structure.html">Article 03 ‚Äî Component File Structure</a> ‚Äî CSS scoping at compile time, the LWC bundle contract.</li>
          <li><a href="16-accessibility.html">Article 16 ‚Äî Accessibility</a> ‚Äî Using SLDS classes for accessible forms, modals, and keyboard navigation.</li>
        </ul>
      </section>

      <!-- Article Nav -->
      <nav class="article-nav" aria-label="Article navigation">
        <a href="11-dynamic-components.html" class="nav-prev">
          <span class="nav-label">‚Üê Previous</span>
          <span class="nav-title">11. Dynamic Components</span>
        </a>
        <a href="13-security.html" class="nav-next">
          <span class="nav-label">Next ‚Üí</span>
          <span class="nav-title">13. Security: LWS, Locker Service &amp; CSP</span>
        </a>
      </nav>

    </main><!-- /.article-main -->
  </div><!-- /.article-page -->

  <!-- ================================================================
       SITE FOOTER
       ================================================================ -->
  <footer class="site-footer" role="contentinfo">
    <p>
      <a href="../index.html">‚Üê Back to all articles</a> ‚Ä¢
      <a href="https://developer.salesforce.com/docs/component-library/documentation/en/lwc" target="_blank" rel="noopener noreferrer">Official LWC Docs</a>
    </p>
    <p class="footer-disclaimer">
      Lightning Web Components (LWC) and Salesforce are trademarks of Salesforce, Inc.
      This site is an independent educational resource and is not affiliated with,
      endorsed by, or sponsored by Salesforce, Inc.
    </p>
    <p class="footer-copyright">&#169; 2026 Mohak Purushottam Pingle. Content licensed under MIT.</p>
  </footer>

  <!-- ================================================================
       SCRIPTS
       ================================================================ -->
  <script src="../assets/prism.min.js"></script>
  <script src="../assets/prism-javascript.min.js"></script>
  <script src="../assets/prism-markup.min.js"></script>
  <script src="../assets/prism-css.min.js"></script>
  <script src="../assets/prism-json.min.js"></script>
  <script src="../search.js"></script>

  <script>
    // ----------------------------------------------------------------
    // 1. Dark / Light Theme Toggle
    // ----------------------------------------------------------------
    (function () {
      const toggle     = document.getElementById('themeToggle');
      const themeLabel = document.getElementById('themeLabel');
      const html       = document.documentElement;

      function applyTheme(theme) {
        html.setAttribute('data-theme', theme);
        if (themeLabel) themeLabel.textContent = theme === 'dark' ? 'Light' : 'Dark';
        try { localStorage.setItem('lwc_blog_theme', theme); } catch { /* */ }
      }

      try {
        const saved = localStorage.getItem('lwc_blog_theme');
        if (saved === 'dark' || saved === 'light') applyTheme(saved);
      } catch { /* */ }

      if (toggle) {
        toggle.addEventListener('click', () => {
          const current = html.getAttribute('data-theme') || 'light';
          applyTheme(current === 'dark' ? 'light' : 'dark');
        });
      }
    })();

    // ----------------------------------------------------------------
    // 2. Mark as Read (localStorage)
    // ----------------------------------------------------------------
    (function () {
      const btn       = document.getElementById('markReadBtn');
      const articleId = btn ? btn.getAttribute('data-article-id') : null;
      const key       = articleId ? `lwc_read_${articleId}` : null;

      function syncBtn(read) {
        if (!btn) return;
        btn.textContent    = read ? '‚úì Read' : 'Mark as Read';
        btn.setAttribute('aria-pressed', read ? 'true' : 'false');
        btn.classList.toggle('mark-read-btn--done', read);
      }

      if (key) {
        try {
          const wasRead = localStorage.getItem(key) === 'true';
          syncBtn(wasRead);
        } catch { /* */ }

        btn.addEventListener('click', () => {
          try {
            const wasRead = localStorage.getItem(key) === 'true';
            localStorage.setItem(key, (!wasRead).toString());
            syncBtn(!wasRead);
          } catch { /* */ }
        });
      }
    })();

    // ----------------------------------------------------------------
    // 3. Collapsible Callout Boxes
    // ----------------------------------------------------------------
    (function () {
      document.querySelectorAll('.callout__header').forEach(header => {
        header.addEventListener('click', () => {
          const body    = header.nextElementSibling;
          const isOpen  = header.getAttribute('aria-expanded') === 'true';
          header.setAttribute('aria-expanded', String(!isOpen));
          body.style.display = isOpen ? 'none' : '';
        });

        header.addEventListener('keydown', e => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            header.click();
          }
        });
      });
    })();

    // ----------------------------------------------------------------
    // 4. Scroll-Spy TOC
    // ----------------------------------------------------------------
    (function () {
      const sections = document.querySelectorAll('section[id]');
      const tocLinks = document.querySelectorAll('.toc-list a');

      if (!sections.length || !tocLinks.length) return;

      const observer = new IntersectionObserver(entries => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            tocLinks.forEach(a => a.classList.remove('active'));
            const active = document.querySelector(`.toc-list a[href="#${entry.target.id}"]`);
            if (active) active.classList.add('active');
          }
        });
      }, { rootMargin: '-20% 0px -70% 0px' });

      sections.forEach(s => observer.observe(s));
    })();
  </script>

</body>
</html>
