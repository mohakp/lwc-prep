<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>05. Lifecycle Hooks ‚Äî LWC.guide</title>
  <meta name="description" content="A first-principles deep-dive into LWC lifecycle hooks: browser Custom Elements mapping, parent-child execution order, constructor/connectedCallback/renderedCallback/disconnectedCallback/errorCallback, infinite loop traps, and error boundary patterns.">
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'; connect-src 'none'; frame-ancestors 'none';">
  <meta http-equiv="X-Content-Type-Options" content="nosniff">
  <meta name="referrer" content="strict-origin-when-cross-origin">
  <link rel="canonical" href="https://mohakp.github.io/lwc-prep/articles/05-lifecycle-hooks.html">
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="../assets/prism.min.css">
</head>
<body>

  <!-- ================================================================
       SITE HEADER
       ================================================================ -->
  <header class="site-header" role="banner">
    <div class="site-header__inner">
      <a href="../index.html" class="site-logo" aria-label="LWC.guide Home">
        LWC<span>.</span>guide
      </a>
      <nav class="site-nav" aria-label="Site navigation">
        <button
          class="theme-toggle"
          id="themeToggle"
          aria-label="Toggle dark/light mode"
          title="Toggle dark/light mode"
        >
          <span class="icon-moon" aria-hidden="true">üåô</span>
          <span class="icon-sun"  aria-hidden="true">‚òÄÔ∏è</span>
          <span id="themeLabel">Dark</span>
        </button>
      </nav>
    </div>
  </header>

  <!-- ================================================================
       ARTICLE LAYOUT (sidebar TOC + main content)
       ================================================================ -->
  <div class="article-page">

    <!-- ----- Sticky TOC Sidebar ----- -->
    <aside class="toc-sidebar" aria-label="Table of contents">
      <nav class="toc-sidebar__inner">
        <div class="toc-sidebar__title">Contents</div>
        <ul class="toc-list" id="tocList">
          <li><a href="#hook">1. Why Lifecycle Hooks Matter</a></li>
          <li><a href="#mental-model">2. Mental Model: Browser Custom Elements</a></li>
          <li class="level-3"><a href="#browser-callbacks">Browser Lifecycle Callbacks</a></li>
          <li class="level-3"><a href="#lwc-mapping">LWC's Mapping &amp; Extensions</a></li>
          <li><a href="#execution-order">3. Full Execution Order</a></li>
          <li class="level-3"><a href="#single-component">Single Component Flow</a></li>
          <li class="level-3"><a href="#parent-child-order">Parent-Child Nesting Order</a></li>
          <li class="level-3"><a href="#three-level-nesting">Three-Level Nesting</a></li>
          <li><a href="#constructor">4. constructor()</a></li>
          <li class="level-3"><a href="#constructor-rules">What You Can and Cannot Do</a></li>
          <li class="level-3"><a href="#constructor-super">Why super() Must Be First</a></li>
          <li><a href="#connected-callback">5. connectedCallback()</a></li>
          <li class="level-3"><a href="#connected-dom-guarantees">DOM Availability Guarantees</a></li>
          <li class="level-3"><a href="#connected-lms">LMS Subscription Pattern</a></li>
          <li class="level-3"><a href="#connected-multiple-calls">Multiple Calls on Re-insertion</a></li>
          <li><a href="#rendered-callback">6. renderedCallback()</a></li>
          <li class="level-3"><a href="#rendered-every-vs-first">Every Render vs First Render</a></li>
          <li class="level-3"><a href="#infinite-loop-trap">The Infinite Loop Trap</a></li>
          <li class="level-3"><a href="#rendered-guard">The _initialized Guard</a></li>
          <li><a href="#disconnected-callback">7. disconnectedCallback()</a></li>
          <li class="level-3"><a href="#cleanup-responsibilities">Cleanup Responsibilities</a></li>
          <li class="level-3"><a href="#memory-leak-prevention">Memory Leak Prevention</a></li>
          <li><a href="#error-callback">8. errorCallback(error, stack)</a></li>
          <li class="level-3"><a href="#error-vs-trycatch">vs try-catch ‚Äî Key Differences</a></li>
          <li class="level-3"><a href="#error-boundary-pattern">Error Boundary Pattern</a></li>
          <li><a href="#getters-vs-connected">9. Getters vs connectedCallback</a></li>
          <li><a href="#is-connected">10. isConnected Property</a></li>
          <li><a href="#pitfalls">11. Pitfall Catalogue</a></li>
          <li><a href="#p3-insight">12. Expert Insight</a></li>
          <li><a href="#recall">13. Quick Recall Card</a></li>
        </ul>
      </nav>
    </aside>

    <!-- ----- Main Article Content ----- -->
    <main class="article-main" id="articleMain">

      <!-- Article Header -->
      <header class="article-header">
        <div class="article-breadcrumb">
          <a href="../index.html">‚Üê All Articles</a>
        </div>
        <div class="article-number">Article 05</div>
        <h1>Lifecycle Hooks</h1>
        <div class="article-meta">
          <span>‚è± 22 min read</span>
          <span class="tags">
            <span class="tag">#decorators-lifecycle</span>
            <span class="tag">#fundamentals</span>
          </span>
        </div>
        <button
          class="mark-read-btn"
          id="markReadBtn"
          data-article-id="05"
          aria-pressed="false"
        >
          ‚òê Mark as Read
        </button>
      </header>

      <!-- ============================================================
           1. HOOK
           ============================================================ -->
      <section id="hook">
        <h2>1. Why Lifecycle Hooks Matter</h2>
        <p>
          A component is not alive the moment you instantiate it. It moves through a sequence of
          platform-managed phases ‚Äî creation, connection to the DOM, rendering, updates, and
          eventual disconnection ‚Äî and you get exactly five named hooks to inject your logic at
          the right phase. Miss the window and you'll either operate on a DOM that doesn't exist
          yet, create memory leaks by never cleaning up subscriptions, or accidentally trigger
          an infinite re-render loop that brings the page to its knees.
        </p>
        <p>
          The stakes are high because <strong>the hooks interact</strong>. Setting a reactive
          property inside <code>renderedCallback()</code> triggers another render, which fires
          <code>renderedCallback()</code> again. Subscribing to LMS in <code>connectedCallback()</code>
          but forgetting to unsubscribe in <code>disconnectedCallback()</code> silently leaks a
          listener that keeps a reference to the component object long after the DOM is gone.
        </p>
        <p>
          A expert developer must know not just what each hook does, but <em>exactly when</em> it
          fires relative to its parent and children, what the platform guarantees about DOM
          availability at each point, and which operations are safe vs unsafe. This article builds
          that mental model from the browser's Custom Elements specification upward.
        </p>
      </section>

      <!-- ============================================================
           2. MENTAL MODEL
           ============================================================ -->
      <section id="mental-model">
        <h2>2. Mental Model: Browser Custom Elements</h2>

        <h3 id="browser-callbacks">Browser Lifecycle Callbacks</h3>
        <p>
          LWC is built on the <a href="https://html.spec.whatwg.org/multipage/custom-elements.html"
          target="_blank" rel="noopener noreferrer">Web Components Custom Elements specification</a>. Before
          understanding LWC hooks, understand the four browser-native callbacks the spec defines:
        </p>
        <ul>
          <li>
            <strong><code>constructor()</code></strong> ‚Äî Called when the element is created via
            <code>new</code> or parsed from HTML. The shadow root may be attached here.
            No children are parsed yet.
          </li>
          <li>
            <strong><code>connectedCallback()</code></strong> ‚Äî Called each time the element is
            inserted into a connected document. This is the first point where
            <code>this.getRootNode()</code> returns a shadow root.
          </li>
          <li>
            <strong><code>disconnectedCallback()</code></strong> ‚Äî Called each time the element
            is removed from a connected document. Cleanup goes here.
          </li>
          <li>
            <strong><code>attributeChangedCallback(name, oldVal, newVal)</code></strong> ‚Äî Called
            when an observed attribute changes. Requires a static
            <code>observedAttributes</code> getter.
          </li>
          <li>
            <strong><code>adoptedCallback()</code></strong> ‚Äî Called when the element is moved to
            a new document (rare ‚Äî mostly relevant for <code>document.adoptNode()</code>).
          </li>
        </ul>
        <p>
          Here's a minimal vanilla custom element to see these in action:
        </p>
        <pre><code class="language-javascript">class MyCounter extends HTMLElement {
  constructor() {
    super(); // ALWAYS first
    this._count = 0;
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `&lt;p&gt;Count: ${this._count}&lt;/p&gt;`;
    console.log('connected ‚Äî DOM is live');
  }

  disconnectedCallback() {
    console.log('removed from DOM ‚Äî clean up here');
  }

  static get observedAttributes() { return ['start']; }

  attributeChangedCallback(name, oldVal, newVal) {
    if (name === 'start') this._count = Number(newVal);
  }
}

customElements.define('my-counter', MyCounter);</code></pre>

        <h3 id="lwc-mapping">LWC's Mapping &amp; Extensions</h3>
        <p>
          LWC maps directly onto three of the browser callbacks and adds two of its own:
        </p>
        <table>
          <thead>
            <tr>
              <th>Browser Custom Element</th>
              <th>LWC Equivalent</th>
              <th>Notes</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>constructor()</code></td>
              <td><code>constructor()</code></td>
              <td>Same signature; <code>super()</code> mandatory</td>
            </tr>
            <tr>
              <td><code>connectedCallback()</code></td>
              <td><code>connectedCallback()</code></td>
              <td>Fires on every DOM insertion</td>
            </tr>
            <tr>
              <td><code>disconnectedCallback()</code></td>
              <td><code>disconnectedCallback()</code></td>
              <td>Fires on every DOM removal</td>
            </tr>
            <tr>
              <td><code>attributeChangedCallback()</code></td>
              <td><em>Not exposed</em></td>
              <td>Handled internally by LWC's reactive engine via <code>@api</code></td>
            </tr>
            <tr>
              <td><code>adoptedCallback()</code></td>
              <td><em>Not exposed</em></td>
              <td>Not applicable in Salesforce's single-document model</td>
            </tr>
            <tr>
              <td><em>N/A (LWC-specific)</em></td>
              <td><code>renderedCallback()</code></td>
              <td>Fires after every render cycle (including updates)</td>
            </tr>
            <tr>
              <td><em>N/A (LWC-specific)</em></td>
              <td><code>errorCallback(error, stack)</code></td>
              <td>Error boundary ‚Äî catches errors in child lifecycle hooks</td>
            </tr>
          </tbody>
        </table>
        <p>
          The key insight: <code>attributeChangedCallback</code> is replaced by LWC's reactive
          engine. When a parent sets a child's <code>@api</code> property, LWC internally calls
          the property setter and schedules a re-render ‚Äî no raw attribute watching needed.
          This is safer (type-checked, strongly named) and requires zero boilerplate.
        </p>
      </section>

      <!-- ============================================================
           3. EXECUTION ORDER
           ============================================================ -->
      <section id="execution-order">
        <h2>3. Full Execution Order</h2>

        <h3 id="single-component">Single Component Flow</h3>
        <p>
          For a single LWC component (no children), the sequence is:
        </p>
        <pre><code class="language-javascript">constructor()          // component instance created
  ‚Üì
connectedCallback()    // inserted into DOM; template not rendered yet
  ‚Üì
render()               // LWC internal: template function executes
  ‚Üì
renderedCallback()     // template is in the DOM; first render complete
  ‚Üì
[reactive change]      // @api property set, @track mutation, @wire resolves...
  ‚Üì
render()               // re-render
  ‚Üì
renderedCallback()     // fires again after every re-render
  ‚Üì
disconnectedCallback() // component removed from DOM</code></pre>
        <p>
          A common misconception: <code>connectedCallback()</code> fires
          <strong>before</strong> the template is rendered. If you call
          <code>this.template.querySelector()</code> inside <code>connectedCallback()</code>,
          you will get <code>null</code> for elements defined in the template ‚Äî the DOM nodes
          haven't been created yet. Use <code>renderedCallback()</code> for template DOM access.
        </p>

        <h3 id="parent-child-order">Parent-Child Nesting Order</h3>
        <p>
          When a parent component contains a child component, the lifecycle interleaves in a
          specific, deterministic pattern. Understanding this is a must for Expert:
        </p>
        <figure style="margin: 1.5rem 0; text-align: center;">
          <img src="../assets/diagrams/lifecycle-execution-order.svg"
               alt="LWC Lifecycle Execution Order diagram showing single component flow and parent-child-grandchild numbered execution sequence"
               style="max-width: 100%; border-radius: 8px; border: 1px solid var(--color-border);">
          <figcaption style="margin-top: 0.5rem; font-size: 0.85rem; color: var(--color-text-muted);">
            Fig 1 ‚Äî Full LWC lifecycle: single component flow (left) and parent‚Üíchild‚Üígrandchild execution order (right).
            Steps 1‚Äì9 are top-down; steps 10‚Äì12 (renderedCallback) bubble bottom-up.
          </figcaption>
        </figure>
        <pre><code class="language-javascript">// Mount sequence (top-down creation, bottom-up rendering):
Parent constructor()
Parent connectedCallback()
  Child constructor()
  Child connectedCallback()
  Child render()
  Child renderedCallback()     ‚Üê child renders FIRST
Parent render()                ‚Üê parent renders AFTER children
Parent renderedCallback()      ‚Üê parent's renderedCallback fires LAST

// Unmount sequence (bottom-up ‚Äî children first):
Child disconnectedCallback()   ‚Üê child cleans up first
Parent disconnectedCallback()  ‚Üê parent cleans up last</code></pre>
        <p>
          The rule of thumb:
        </p>
        <ul>
          <li><strong>Construction &amp; connection</strong>: parent ‚Üí child (top-down)</li>
          <li><strong>Rendering completion (<code>renderedCallback</code>)</strong>: child ‚Üí parent (bottom-up)</li>
          <li><strong>Disconnection</strong>: child ‚Üí parent (bottom-up)</li>
        </ul>
        <div class="callout callout--insight">
          <div class="callout__header" aria-expanded="true" tabindex="0" role="button">
            <span class="callout__icon">üí°</span>
            <span class="callout__title">Why does renderedCallback fire bottom-up?</span>
            <span class="callout__toggle">‚ñº</span>
          </div>
          <div class="callout__body">
            <p>
              A parent's template is only fully rendered when all its child components have
              completed their own render cycles. So the platform can only meaningfully call
              the parent's <code>renderedCallback()</code> after the children's
              <code>renderedCallback()</code> has fired. This guarantees that when your parent's
              <code>renderedCallback()</code> runs, the full component subtree is in the DOM.
            </p>
          </div>
        </div>

        <h3 id="three-level-nesting">Three-Level Nesting</h3>
        <p>
          With three levels (Grandparent ‚Üí Parent ‚Üí Child), the pattern extends predictably:
        </p>
        <pre><code class="language-javascript">// Mount:
Grandparent constructor()
Grandparent connectedCallback()
  Parent constructor()
  Parent connectedCallback()
    Child constructor()
    Child connectedCallback()
    Child render()
    Child renderedCallback()
  Parent render()
  Parent renderedCallback()
Grandparent render()
Grandparent renderedCallback()

// Unmount:
Child disconnectedCallback()
Parent disconnectedCallback()
Grandparent disconnectedCallback()</code></pre>
        <p>
          This matters when you need to know whether a grandchild's public property is accessible
          from the grandparent's <code>renderedCallback()</code>. It is ‚Äî by the time grandparent's
          <code>renderedCallback()</code> fires, the entire subtree has rendered.
        </p>
      </section>

      <!-- ============================================================
           4. CONSTRUCTOR
           ============================================================ -->
      <section id="constructor">
        <h2>4. <code>constructor()</code></h2>
        <p>
          The constructor fires when the component class is instantiated ‚Äî before it's connected
          to any document. It's the earliest possible hook and also the most restricted.
        </p>

        <h3 id="constructor-rules">What You Can and Cannot Do</h3>
        <table>
          <thead>
            <tr>
              <th>Operation</th>
              <th>Allowed?</th>
              <th>Reason</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Call <code>super()</code></td>
              <td>‚úÖ Required</td>
              <td>Must be the very first statement</td>
            </tr>
            <tr>
              <td>Initialize class fields / primitive properties</td>
              <td>‚úÖ Yes</td>
              <td>Safe ‚Äî no DOM dependency</td>
            </tr>
            <tr>
              <td>Access <code>this.template</code></td>
              <td>‚ùå No</td>
              <td>Shadow root not yet attached</td>
            </tr>
            <tr>
              <td>Access <code>this.template.querySelector()</code></td>
              <td>‚ùå No</td>
              <td>Template hasn't rendered yet</td>
            </tr>
            <tr>
              <td>Access child component elements</td>
              <td>‚ùå No</td>
              <td>Children don't exist yet</td>
            </tr>
            <tr>
              <td>Access <code>@api</code> properties set by parent</td>
              <td>‚ùå No</td>
              <td>Parent hasn't set them yet</td>
            </tr>
            <tr>
              <td>Dispatch custom events</td>
              <td>‚ùå No</td>
              <td>Not connected to a document; events won't bubble</td>
            </tr>
            <tr>
              <td>Assign to <code>@api</code> decorated properties</td>
              <td>‚ùå No</td>
              <td>Will throw an error ‚Äî treat as read-only from the class itself</td>
            </tr>
          </tbody>
        </table>
        <pre><code class="language-javascript">import { LightningElement, api, track } from 'lwc';

export default class MyComponent extends LightningElement {
  // ‚úÖ Class field initialization ‚Äî fine in constructor context
  _data = [];
  _isLoaded = false;
  _subscriptions = [];

  constructor() {
    super(); // ALWAYS FIRST ‚Äî no code before this line

    // ‚úÖ Initialize private state
    this._initTime = Date.now();

    // ‚ùå WRONG ‚Äî do NOT do this:
    // this.template.querySelector('button');  // undefined ‚Äî template not rendered
    // this.dispatchEvent(new CustomEvent('init')); // no document connection yet
  }
}</code></pre>

        <h3 id="constructor-super">Why <code>super()</code> Must Be First</h3>
        <p>
          LWC components extend <code>LightningElement</code>, which itself extends the browser's
          <code>HTMLElement</code>. The ES2015 class inheritance rule is that derived class
          constructors must call <code>super()</code> before accessing <code>this</code>.
          Attempting to reference <code>this</code> before <code>super()</code> throws a
          <code>ReferenceError: Must call super constructor in derived class before accessing
          'this'</code> ‚Äî this is enforced at the JavaScript engine level, not by LWC.
        </p>
        <p>
          Practically, the <code>LightningElement</code> constructor sets up the reactive engine
          internals (property proxying, the wire service context, the shadow root attachment).
          None of that exists until <code>super()</code> runs, so any attempt to use
          <code>this</code> before it is meaningless.
        </p>
        <pre><code class="language-javascript">constructor() {
  // WRONG ‚Äî will throw ReferenceError
  this._value = 42; // ‚Üê ReferenceError!
  super();
}

constructor() {
  // CORRECT
  super();
  this._value = 42; // ‚Üê safe after super()
}</code></pre>
      </section>

      <!-- ============================================================
           5. CONNECTED CALLBACK
           ============================================================ -->
      <section id="connected-callback">
        <h2>5. <code>connectedCallback()</code></h2>
        <p>
          <code>connectedCallback()</code> fires when the component is inserted into the DOM.
          This is the primary initialization hook for most real-world logic. At this point:
        </p>
        <ul>
          <li>The component is part of the document</li>
          <li><code>this.isConnected</code> returns <code>true</code></li>
          <li>The element can dispatch custom events that will bubble</li>
          <li>But: the <strong>template has not yet rendered</strong> ‚Äî child DOM nodes are not present</li>
        </ul>

        <h3 id="connected-dom-guarantees">DOM Availability Guarantees</h3>
        <p>
          This is the most commonly misunderstood point:
        </p>
        <pre><code class="language-javascript">connectedCallback() {
  // ‚úÖ 'this' is connected ‚Äî isConnected is true
  console.log(this.isConnected); // true

  // ‚úÖ Can dispatch events
  this.dispatchEvent(new CustomEvent('componentmounted'));

  // ‚úÖ Can set reactive properties (will trigger a render)
  this._recordId = this.recordId;

  // ‚ùå Template DOM is NOT available yet
  const btn = this.template.querySelector('button'); // returns null!

  // ‚úÖ @api properties set by parent ARE available here
  console.log(this.recordId); // value set by parent binding is accessible
}</code></pre>
        <p>
          The reason template DOM isn't available is timing: <code>connectedCallback()</code>
          fires before LWC's rendering engine has executed the template function and appended
          the resulting DOM nodes into the shadow root. The render happens asynchronously
          (or rather, in a subsequent microtask/frame), so by the time rendering completes,
          <code>renderedCallback()</code> fires.
        </p>

        <h3 id="connected-lms">LMS Subscription Pattern</h3>
        <p>
          The canonical pattern for Lightning Message Service (LMS) subscriptions is to subscribe
          in <code>connectedCallback()</code> and unsubscribe in <code>disconnectedCallback()</code>:
        </p>
        <pre><code class="language-javascript">import { LightningElement, wire } from 'lwc';
import { subscribe, unsubscribe, MessageContext } from 'lightning/messageService';
import SAMPLE_MC from '@salesforce/messageChannel/SampleMessageChannel__c';

export default class MySubscriber extends LightningElement {
  @wire(MessageContext)
  messageContext;

  _subscription = null;

  connectedCallback() {
    // Subscribe when component is added to DOM
    this._subscription = subscribe(
      this.messageContext,
      SAMPLE_MC,
      (message) => this._handleMessage(message)
    );
  }

  disconnectedCallback() {
    // CRITICAL: unsubscribe to prevent memory leak
    unsubscribe(this._subscription);
    this._subscription = null;
  }

  _handleMessage(message) {
    // process incoming message
    console.log('Received:', message);
  }
}</code></pre>
        <p>
          Why store the subscription reference? <code>unsubscribe()</code> needs it. Without it
          you cannot unsubscribe, leaving a live listener pointing to a detached component ‚Äî
          a classic JavaScript memory leak pattern where the garbage collector cannot collect
          the component object because the LMS registry still holds a reference.
        </p>

        <h3 id="connected-multiple-calls">Multiple Calls on Re-insertion</h3>
        <p>
          <code>connectedCallback()</code> fires <strong>every time</strong> the component is
          inserted into the DOM, not just the first time. If a parent component conditionally
          renders a child using <code>lwc:if</code>, the child's <code>connectedCallback()</code>
          fires each time the condition becomes true. This has implications:
        </p>
        <pre><code class="language-javascript">// Problem: double-subscribing if connectedCallback fires twice
connectedCallback() {
  // If this fires twice without a disconnectedCallback guard,
  // you'll have two subscriptions!
  this._subscription = subscribe(
    this.messageContext,
    SAMPLE_MC,
    (msg) => this._handleMessage(msg)
  );
}

// Solution: guard against double subscription
connectedCallback() {
  if (!this._subscription) {
    this._subscription = subscribe(
      this.messageContext,
      SAMPLE_MC,
      (msg) => this._handleMessage(msg)
    );
  }
}</code></pre>
      </section>

      <!-- ============================================================
           6. RENDERED CALLBACK
           ============================================================ -->
      <section id="rendered-callback">
        <h2>6. <code>renderedCallback()</code></h2>
        <p>
          <code>renderedCallback()</code> is an LWC-specific hook with no direct Custom Elements
          equivalent. It fires after every render cycle ‚Äî both the initial render and every
          subsequent re-render triggered by reactive changes. At this point the full template
          DOM is available inside <code>this.template</code>.
        </p>

        <h3 id="rendered-every-vs-first">Every Render vs First Render</h3>
        <p>
          A critical distinction: this hook fires on <em>every</em> render, not just the first.
          A component that receives 10 <code>@api</code> property changes will trigger 10
          renderedCallback calls. This means any code inside must be either:
        </p>
        <ol>
          <li><strong>Safe to run multiple times</strong> (idempotent), or</li>
          <li><strong>Guarded</strong> with an initialization flag to run only once</li>
        </ol>
        <pre><code class="language-javascript">// ‚úÖ Safe to run every time (reads DOM, doesn't create side effects)
renderedCallback() {
  const height = this.template.querySelector('.container').offsetHeight;
  console.log('Container height:', height);
}

// ‚úÖ Guarded ‚Äî runs only on first render
_initialized = false;

renderedCallback() {
  if (this._initialized) return;
  this._initialized = true;

  // One-time setup (e.g., initializing a third-party library)
  const canvas = this.template.querySelector('canvas');
  this._chart = new Chart(canvas, this._chartConfig);
}</code></pre>

        <h3 id="infinite-loop-trap">The Infinite Loop Trap</h3>
        <p>
          The most dangerous mistake in LWC is setting a reactive property (a plain property,
          <code>@track</code>, or anything that triggers re-render) inside
          <code>renderedCallback()</code> without a guard:
        </p>
        <pre><code class="language-javascript">// ‚ùå INFINITE LOOP ‚Äî do NOT do this
_count = 0;

renderedCallback() {
  this._count++;  // ‚Üê reactive change triggers re-render
                  // ‚Üê re-render fires renderedCallback() again
                  // ‚Üê infinite loop ‚Üí stack overflow / browser hang
}

// ‚úÖ CORRECT ‚Äî guard prevents infinite loop
_count = 0;
_rendered = false;

renderedCallback() {
  if (this._rendered) return;
  this._rendered = true;
  this._count++;  // only runs once
}</code></pre>
        <p>
          In LWC's reactive engine, any assignment to a tracked property (or any plain property
          that the reactive engine detects as changed) during a render callback schedules
          another render. Without a guard, this creates an infinite cycle. Salesforce does not
          automatically detect or break these loops ‚Äî the browser will typically run out of call
          stack or the tab will become unresponsive.
        </p>
        <div class="callout callout--pitfall">
          <div class="callout__header" aria-expanded="true" tabindex="0" role="button">
            <span class="callout__icon">‚ö†Ô∏è</span>
            <span class="callout__title">The hidden loop: even getters can cause this</span>
            <span class="callout__toggle">‚ñº</span>
          </div>
          <div class="callout__body">
            <p>
              If a getter referenced in the template performs a side-effect (e.g., incrementing a
              counter or logging), and that side-effect touches a reactive property, you can get
              an infinite loop even without <code>renderedCallback</code>. Getters called by the
              template must be pure ‚Äî no side effects, no reactive property mutations.
            </p>
          </div>
        </div>

        <h3 id="rendered-guard">The <code>_initialized</code> Guard</h3>
        <p>
          The <code>_initialized</code> boolean guard is the standard LWC pattern for one-time
          operations in <code>renderedCallback()</code>. It works because the boolean is a class
          field (not reactive), so assigning to it doesn't trigger a re-render:
        </p>
        <pre><code class="language-javascript">import { LightningElement, api } from 'lwc';
import { loadScript, loadStyle } from 'lightning/platformResourceLoader';
import CHART_JS from '@salesforce/resourceUrl/chartjs';

export default class ChartComponent extends LightningElement {
  @api title = 'My Chart';

  _initialized = false;  // plain field ‚Äî NOT reactive, no re-render trigger

  renderedCallback() {
    if (this._initialized) return; // ‚Üê guard ‚Äî exit if already set up
    this._initialized = true;

    // One-time async library load
    loadScript(this, CHART_JS + '/chart.min.js')
      .then(() => {
        const canvas = this.template.querySelector('canvas');
        this._chart = new Chart(canvas, {
          type: 'bar',
          data: { labels: ['Jan', 'Feb', 'Mar'], datasets: [] }
        });
      })
      .catch(error => {
        console.error('Chart.js load failed:', error);
      });
  }
}</code></pre>
      </section>

      <!-- ============================================================
           7. DISCONNECTED CALLBACK
           ============================================================ -->
      <section id="disconnected-callback">
        <h2>7. <code>disconnectedCallback()</code></h2>
        <p>
          <code>disconnectedCallback()</code> fires when the component is removed from the DOM.
          Like <code>connectedCallback()</code>, it fires every time ‚Äî not just the final
          removal. A component re-added to the DOM will have both callbacks fire again.
        </p>

        <h3 id="cleanup-responsibilities">Cleanup Responsibilities</h3>
        <p>
          Any resource acquired during <code>connectedCallback()</code> or the component's
          lifetime must be released here:
        </p>
        <pre><code class="language-javascript">import { LightningElement, wire } from 'lwc';
import { subscribe, unsubscribe, MessageContext } from 'lightning/messageService';
import NOTIFICATION_MC from '@salesforce/messageChannel/Notification__c';

export default class NotificationListener extends LightningElement {
  @wire(MessageContext) messageContext;

  _subscription = null;
  _intervalId   = null;
  _observer     = null;

  connectedCallback() {
    // 1. LMS subscription
    this._subscription = subscribe(
      this.messageContext,
      NOTIFICATION_MC,
      msg => this._handleNotification(msg)
    );

    // 2. Polling interval
    this._intervalId = setInterval(() => {
      this._refreshData();
    }, 30_000);

    // 3. IntersectionObserver
    this._observer = new IntersectionObserver(entries => {
      this._handleVisibility(entries);
    });
    this._observer.observe(this.template.host);
  }

  disconnectedCallback() {
    // 1. Unsubscribe LMS
    unsubscribe(this._subscription);
    this._subscription = null;

    // 2. Clear interval
    clearInterval(this._intervalId);
    this._intervalId = null;

    // 3. Disconnect observer
    if (this._observer) {
      this._observer.disconnect();
      this._observer = null;
    }
  }
}</code></pre>

        <h3 id="memory-leak-prevention">Memory Leak Prevention</h3>
        <p>
          JavaScript's garbage collector cannot collect an object if any live reference points
          to it. A detached LWC component that has active subscriptions or intervals is held in
          memory by those references. In a long-lived Salesforce page with dynamic navigation
          (Lightning App Builder tabs, Flows), components are regularly mounted and unmounted.
          Failing to clean up in <code>disconnectedCallback()</code> results in ever-growing
          memory consumption ‚Äî invisible until the page becomes sluggish or crashes.
        </p>
        <p>
          Resources that commonly cause leaks:
        </p>
        <ul>
          <li>LMS subscriptions (<code>subscribe()</code>)</li>
          <li>EMP API subscriptions (<code>lightning/empApi</code>)</li>
          <li><code>setInterval</code> / <code>setTimeout</code> references</li>
          <li><code>IntersectionObserver</code> and <code>ResizeObserver</code> instances</li>
          <li><code>document.addEventListener</code> callbacks (also an anti-pattern in LWC)</li>
          <li>Third-party library instances that hold DOM/network references</li>
        </ul>
        <div class="callout callout--insight">
          <div class="callout__header" aria-expanded="true" tabindex="0" role="button">
            <span class="callout__icon">üí°</span>
            <span class="callout__title">Why document.addEventListener is a double anti-pattern in LWC</span>
            <span class="callout__toggle">‚ñº</span>
          </div>
          <div class="callout__body">
            <p>
              Using <code>document.addEventListener</code> inside an LWC component is
              problematic for two reasons: (1) it bypasses Shadow DOM encapsulation and can
              interfere with other components, and (2) if not removed in
              <code>disconnectedCallback()</code>, it keeps the component alive in memory
              indefinitely. Prefer <code>this.template.addEventListener</code> for scoped
              listeners, or use LMS for cross-component communication.
            </p>
          </div>
        </div>
      </section>

      <!-- ============================================================
           8. ERROR CALLBACK
           ============================================================ -->
      <section id="error-callback">
        <h2>8. <code>errorCallback(error, stack)</code></h2>
        <p>
          <code>errorCallback(error, stack)</code> is LWC's error boundary mechanism ‚Äî a hook
          that exists only in LWC (not in the browser Custom Elements spec). When any lifecycle
          hook or render function in a <strong>child</strong> component throws an unhandled
          error, the parent's <code>errorCallback()</code> is invoked with the error object and
          a stack trace string.
        </p>
        <pre><code class="language-javascript">// Parent component ‚Äî acts as the error boundary
export default class ErrorBoundary extends LightningElement {
  _hasError = false;
  _errorMessage = '';

  errorCallback(error, stack) {
    // error: the thrown Error object
    // stack: string ‚Äî the component stack at the point of failure
    this._hasError = true;
    this._errorMessage = error.message;
    console.error('Child component error:', error);
    console.error('Component stack:', stack);

    // Optionally log to a Salesforce custom object via Apex
    // logError({ message: error.message, stack });
  }
}

// Parent template ‚Äî conditionally shows error UI
&lt;template&gt;
  &lt;template lwc:if={_hasError}&gt;
    &lt;div class="slds-notify slds-notify_alert" role="alert"&gt;
      Something went wrong: {_errorMessage}
    &lt;/div&gt;
  &lt;/template&gt;
  &lt;template lwc:else&gt;
    &lt;c-potentially-broken-child&gt;&lt;/c-potentially-broken-child&gt;
  &lt;/template&gt;
&lt;/template&gt;</code></pre>

        <h3 id="error-vs-trycatch">vs <code>try-catch</code> ‚Äî Key Differences</h3>
        <table>
          <thead>
            <tr>
              <th>Aspect</th>
              <th><code>try-catch</code></th>
              <th><code>errorCallback</code></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>What it catches</td>
              <td>Errors in the <em>same</em> synchronous code block or <code>await</code>ed promises</td>
              <td>Errors thrown by child component lifecycle hooks and render functions</td>
            </tr>
            <tr>
              <td>Scope</td>
              <td>Local to the try block</td>
              <td>Across the entire child component subtree</td>
            </tr>
            <tr>
              <td>Async errors</td>
              <td>Requires <code>try/catch</code> inside <code>async</code> function</td>
              <td>Does NOT catch async errors or event handler errors</td>
            </tr>
            <tr>
              <td>Recovery</td>
              <td>Inline recovery, execution continues</td>
              <td>Replaces child with fallback UI via reactive state</td>
            </tr>
            <tr>
              <td>Stack info</td>
              <td>Via <code>error.stack</code></td>
              <td>Separate <code>stack</code> parameter (component-level stack)</td>
            </tr>
          </tbody>
        </table>

        <h3 id="error-boundary-pattern">Error Boundary Pattern</h3>
        <p>
          The recommended pattern is to create a dedicated <code>errorBoundary</code> wrapper
          component that wraps risky child subtrees. This follows React's error boundary concept
          but implemented with LWC primitives:
        </p>
        <pre><code class="language-javascript">// c/errorBoundary/errorBoundary.js
import { LightningElement, api } from 'lwc';

export default class ErrorBoundary extends LightningElement {
  @api label = 'An error occurred';

  hasError = false;
  errorDetails = '';

  errorCallback(error, stack) {
    this.hasError = true;
    this.errorDetails = `${error.message}\n\n${stack}`;
  }
}</code></pre>
        <pre><code class="language-html">&lt;!-- c/errorBoundary/errorBoundary.html --&gt;
&lt;template&gt;
  &lt;template lwc:if={hasError}&gt;
    &lt;div class="error-boundary"&gt;
      &lt;lightning-icon icon-name="utility:error" variant="error"&gt;&lt;/lightning-icon&gt;
      &lt;p&gt;{label}&lt;/p&gt;
    &lt;/div&gt;
  &lt;/template&gt;
  &lt;template lwc:else&gt;
    &lt;slot&gt;&lt;/slot&gt;  &lt;!-- render children when no error --&gt;
  &lt;/template&gt;
&lt;/template&gt;</code></pre>
        <pre><code class="language-html">&lt;!-- Usage in a parent --&gt;
&lt;template&gt;
  &lt;c-error-boundary label="Chart failed to load"&gt;
    &lt;c-complex-chart data={chartData}&gt;&lt;/c-complex-chart&gt;
  &lt;/c-error-boundary&gt;
&lt;/template&gt;</code></pre>
        <div class="callout callout--pitfall">
          <div class="callout__header" aria-expanded="true" tabindex="0" role="button">
            <span class="callout__icon">‚ö†Ô∏è</span>
            <span class="callout__title">What errorCallback does NOT catch</span>
            <span class="callout__toggle">‚ñº</span>
          </div>
          <div class="callout__body">
            <ul>
              <li>Errors in <strong>event handlers</strong> (e.g., a click handler that throws)</li>
              <li>Errors in <strong>imperative Apex calls</strong> (unhandled promise rejections)</li>
              <li>Errors in the <strong>component that defines</strong> <code>errorCallback</code> itself</li>
              <li>Errors thrown <strong>asynchronously</strong> inside lifecycle hooks (after an <code>await</code>)</li>
            </ul>
            <p>
              For event handler errors and async errors, use <code>try/catch</code> with
              <code>async/await</code>. For unhandled promise rejections, implement a
              <code>window.addEventListener('unhandledrejection')</code> handler at the app level
              (noting this crosses Shadow DOM ‚Äî use with care).
            </p>
          </div>
        </div>
      </section>

      <!-- ============================================================
           9. GETTERS VS CONNECTED CALLBACK
           ============================================================ -->
      <section id="getters-vs-connected">
        <h2>9. Getters vs <code>connectedCallback</code></h2>
        <p>
          A common question: should initialization logic go in a getter or in
          <code>connectedCallback()</code>? They have fundamentally different contracts:
        </p>
        <table>
          <thead>
            <tr>
              <th>Aspect</th>
              <th>Getter</th>
              <th><code>connectedCallback()</code></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>When it runs</td>
              <td>Every time the template accesses it (potentially multiple times per render)</td>
              <td>Once per DOM insertion</td>
            </tr>
            <tr>
              <td>DOM access</td>
              <td>No ‚Äî runs during rendering, DOM not finalized</td>
              <td>Limited ‚Äî component is in DOM, but template hasn't rendered</td>
            </tr>
            <tr>
              <td>Async operations</td>
              <td>No ‚Äî getters must be synchronous</td>
              <td>Yes ‚Äî can call async functions, initiate fetches</td>
            </tr>
            <tr>
              <td>Side effects</td>
              <td>Forbidden ‚Äî must be pure / memoized</td>
              <td>Expected ‚Äî designed for side effects like subscriptions</td>
            </tr>
            <tr>
              <td>Performance</td>
              <td>Low overhead if memoized; expensive if not</td>
              <td>Runs once ‚Äî no re-evaluation issue</td>
            </tr>
          </tbody>
        </table>
        <pre><code class="language-javascript">// ‚úÖ Getter for derived/computed values ‚Äî pure, fast, memoizable
get formattedDate() {
  if (!this._date) return '';
  return new Intl.DateTimeFormat('en-US').format(new Date(this._date));
}

// ‚úÖ connectedCallback for one-time initialization
connectedCallback() {
  // Subscribe to LMS, set up intervals, initiate data fetch
  this._fetchInitialData();
}

// ‚ùå Getter performing a side effect ‚Äî wrong place
get currentUser() {
  // This runs EVERY render ‚Äî will call Apex on every re-render!
  fetchCurrentUser({ userId: this.userId });
}</code></pre>
        <p>
          The rule: use getters for computed/derived template values that depend on existing
          reactive state. Use <code>connectedCallback()</code> for anything that has a side
          effect, is async, or should only run once when the component enters the DOM.
        </p>
      </section>

      <!-- ============================================================
           10. IS CONNECTED PROPERTY
           ============================================================ -->
      <section id="is-connected">
        <h2>10. The <code>isConnected</code> Property</h2>
        <p>
          <code>this.isConnected</code> (inherited from <code>Node</code> via <code>HTMLElement</code>)
          returns <code>true</code> if the component is currently attached to a connected document.
          It's useful for guarding async callbacks that might complete after the component has
          been removed from the DOM:
        </p>
        <pre><code class="language-javascript">connectedCallback() {
  // Start a long-running async operation
  this._fetchLargeDataset()
    .then(data => {
      // By the time this resolves, the component might be gone
      if (!this.isConnected) return; // guard!

      this._data = data; // safe to update ‚Äî still in DOM
    });
}

// Also useful in setInterval callbacks
connectedCallback() {
  this._intervalId = setInterval(() => {
    if (!this.isConnected) {
      clearInterval(this._intervalId);
      return;
    }
    this._refresh();
  }, 5000);
}</code></pre>
        <p>
          Without the <code>isConnected</code> guard, an async callback completing after the
          component is removed will try to set a reactive property on a detached component.
          LWC won't crash ‚Äî the property will update silently ‚Äî but it wastes CPU and can
          cause unexpected behavior if the component is later re-inserted.
        </p>
      </section>

      <!-- ============================================================
           11. PITFALLS
           ============================================================ -->
      <section id="pitfalls">
        <h2>11. Pitfall Catalogue</h2>

        <div class="callout callout--pitfall">
          <div class="callout__header" aria-expanded="true" tabindex="0" role="button">
            <span class="callout__icon">‚ö†Ô∏è</span>
            <span class="callout__title">Pitfall 1: Querying template DOM in connectedCallback</span>
            <span class="callout__toggle">‚ñº</span>
          </div>
          <div class="callout__body">
            <pre><code class="language-javascript">// ‚ùå WRONG ‚Äî template not rendered yet
connectedCallback() {
  const el = this.template.querySelector('.my-input'); // null!
  el.focus(); // TypeError: Cannot read property 'focus' of null
}

// ‚úÖ CORRECT ‚Äî use renderedCallback for template DOM access
renderedCallback() {
  if (this._focused) return;
  this._focused = true;
  this.template.querySelector('.my-input')?.focus();
}</code></pre>
          </div>
        </div>

        <div class="callout callout--pitfall">
          <div class="callout__header" aria-expanded="true" tabindex="0" role="button">
            <span class="callout__icon">‚ö†Ô∏è</span>
            <span class="callout__title">Pitfall 2: Setting reactive state in renderedCallback without a guard</span>
            <span class="callout__toggle">‚ñº</span>
          </div>
          <div class="callout__body">
            <pre><code class="language-javascript">// ‚ùå WRONG ‚Äî infinite loop!
renderedCallback() {
  this.count++; // triggers re-render ‚Üí renderedCallback again ‚Üí repeat
}

// ‚úÖ CORRECT ‚Äî use _initialized guard
_initialized = false;
renderedCallback() {
  if (this._initialized) return;
  this._initialized = true;
  this.count++; // runs once
}</code></pre>
          </div>
        </div>

        <div class="callout callout--pitfall">
          <div class="callout__header" aria-expanded="true" tabindex="0" role="button">
            <span class="callout__icon">‚ö†Ô∏è</span>
            <span class="callout__title">Pitfall 3: Forgetting super() or putting code before it</span>
            <span class="callout__toggle">‚ñº</span>
          </div>
          <div class="callout__body">
            <pre><code class="language-javascript">// ‚ùå WRONG ‚Äî ReferenceError at runtime
constructor() {
  this._data = []; // ‚Üê ReferenceError! 'this' unavailable before super()
  super();
}

// ‚úÖ CORRECT
constructor() {
  super(); // always first
  this._data = [];
}</code></pre>
          </div>
        </div>

        <div class="callout callout--pitfall">
          <div class="callout__header" aria-expanded="true" tabindex="0" role="button">
            <span class="callout__icon">‚ö†Ô∏è</span>
            <span class="callout__title">Pitfall 4: Not unsubscribing in disconnectedCallback</span>
            <span class="callout__toggle">‚ñº</span>
          </div>
          <div class="callout__body">
            <pre><code class="language-javascript">// ‚ùå WRONG ‚Äî memory leak
connectedCallback() {
  this._sub = subscribe(this.msgCtx, MY_CHANNEL, msg => this._handle(msg));
  // ... never unsubscribed
}

// ‚úÖ CORRECT
connectedCallback() {
  this._sub = subscribe(this.msgCtx, MY_CHANNEL, msg => this._handle(msg));
}

disconnectedCallback() {
  unsubscribe(this._sub);
  this._sub = null;
}</code></pre>
          </div>
        </div>

        <div class="callout callout--pitfall">
          <div class="callout__header" aria-expanded="true" tabindex="0" role="button">
            <span class="callout__icon">‚ö†Ô∏è</span>
            <span class="callout__title">Pitfall 5: Dispatching events in the constructor</span>
            <span class="callout__toggle">‚ñº</span>
          </div>
          <div class="callout__body">
            <pre><code class="language-javascript">// ‚ùå WRONG ‚Äî element not connected; event will not bubble
constructor() {
  super();
  this.dispatchEvent(new CustomEvent('ready')); // lost in space
}

// ‚úÖ CORRECT ‚Äî dispatch in connectedCallback
connectedCallback() {
  this.dispatchEvent(new CustomEvent('ready')); // bubbles correctly
}</code></pre>
          </div>
        </div>

        <div class="callout callout--pitfall">
          <div class="callout__header" aria-expanded="true" tabindex="0" role="button">
            <span class="callout__icon">‚ö†Ô∏è</span>
            <span class="callout__title">Pitfall 6: Assuming connectedCallback fires only once</span>
            <span class="callout__toggle">‚ñº</span>
          </div>
          <div class="callout__body">
            <pre><code class="language-javascript">// ‚ùå WRONG ‚Äî if lwc:if toggles, this fires multiple times,
// creating multiple subscriptions
connectedCallback() {
  this._sub = subscribe(this.msgCtx, CHANNEL, msg => this._handle(msg));
}

// ‚úÖ CORRECT ‚Äî guard or rely on disconnectedCallback cleanup
connectedCallback() {
  if (!this._sub) {
    this._sub = subscribe(this.msgCtx, CHANNEL, msg => this._handle(msg));
  }
}
disconnectedCallback() {
  unsubscribe(this._sub);
  this._sub = null; // reset so guard works on next connectedCallback
}</code></pre>
          </div>
        </div>
      </section>

      <!-- ============================================================
           12. EXPERT INSIGHT
           ============================================================ -->
      <section id="p3-insight">
        <h2>12. Expert Insight</h2>

        <div class="callout callout--insight">
          <div class="callout__header" aria-expanded="true" tabindex="0" role="button">
            <span class="callout__icon">üèÜ</span>
            <span class="callout__title">Expert Nuances Every Architect Must Know</span>
            <span class="callout__toggle">‚ñº</span>
          </div>
          <div class="callout__body">
            <ul>
              <li>
                <strong>The rendering order is guaranteed but not synchronous:</strong>
                LWC's render cycles are batched. If you set multiple reactive properties in
                the same tick, only one re-render occurs. You cannot depend on renders being
                synchronous ‚Äî always use <code>renderedCallback()</code> to react to DOM state
                after a change, not the next line of code after a property assignment.
              </li>
              <li>
                <strong><code>renderedCallback</code> order in complex trees:</strong>
                In a tree where siblings each have children, the order is depth-first,
                left-to-right for children, then parent. In a large component tree, this
                means the last <code>renderedCallback</code> to fire is the root component's.
                This is the only point where the entire visual tree is stable.
              </li>
              <li>
                <strong><code>errorCallback</code> does not re-throw:</strong>
                When you implement <code>errorCallback</code>, the error is considered handled.
                If you want it to propagate further up the component tree, you must explicitly
                re-throw: <code>throw error;</code> inside <code>errorCallback</code>. Forgetting
                this silently swallows errors that the parent should know about.
              </li>
              <li>
                <strong>Wire adapters fire after <code>connectedCallback</code>:</strong>
                The <code>@wire</code> service resolves data after <code>connectedCallback()</code>.
                If your <code>connectedCallback</code> logic depends on <code>@wire</code> data
                being available, it won't be. Use getters or reactive property setters to react
                to wire results. The wire property setter pattern gives you explicit control:
                <pre><code class="language-javascript">@wire(getAccount, { recordId: '$recordId' })
wiredAccount({ data, error }) {
  if (data) {
    // Wire data is ready ‚Äî trigger dependent logic here
    this._processAccount(data);
  }
}</code></pre>
              </li>
              <li>
                <strong>Using <code>Promise.resolve().then()</code> to defer work:</strong>
                If you need template DOM access from <code>connectedCallback()</code>, defer with
                a microtask: <code>Promise.resolve().then(() => { this.template.querySelector(...) })</code>.
                This works because rendering happens before the microtask queue drains. But it's
                an anti-pattern ‚Äî prefer <code>renderedCallback()</code> which is the platform's
                intended mechanism.
              </li>
              <li>
                <strong>Mixin lifecycle hooks:</strong>
                If your component uses the mixin pattern (e.g.,
                <code>class MyComp extends NavigationMixin(LightningElement)</code>), each mixin
                in the chain may define its own lifecycle hooks. These compose by calling
                <code>super.connectedCallback()</code> in the mixin ‚Äî failing to call
                <code>super</code> in a mixin's lifecycle hook breaks the entire mixin chain.
                Always call <code>super.connectedCallback()</code> if you define lifecycle hooks
                in a mixin.
              </li>
            </ul>
          </div>
        </div>
      </section>

      <!-- ============================================================
           13. QUICK RECALL CARD
           ============================================================ -->
      <section id="recall">
        <h2>13. Quick Recall Card</h2>
        <table>
          <thead>
            <tr>
              <th>Hook</th>
              <th>When it fires</th>
              <th>DOM available?</th>
              <th>Key use</th>
              <th>Main pitfall</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>constructor()</code></td>
              <td>Instantiation (before DOM insert)</td>
              <td>‚ùå No</td>
              <td>Initialize private fields</td>
              <td>Code before <code>super()</code></td>
            </tr>
            <tr>
              <td><code>connectedCallback()</code></td>
              <td>Each DOM insertion</td>
              <td>Partial (no template nodes)</td>
              <td>LMS subscribe, data fetch, intervals</td>
              <td>Template DOM query returns null</td>
            </tr>
            <tr>
              <td><code>renderedCallback()</code></td>
              <td>After every render</td>
              <td>‚úÖ Full</td>
              <td>Third-party lib init, post-render DOM ops</td>
              <td>Infinite loop from reactive property set</td>
            </tr>
            <tr>
              <td><code>disconnectedCallback()</code></td>
              <td>Each DOM removal</td>
              <td>‚ùå No (already removed)</td>
              <td>Unsubscribe, clear intervals, cleanup</td>
              <td>Forgetting to clean up ‚Üí memory leak</td>
            </tr>
            <tr>
              <td><code>errorCallback(err, stack)</code></td>
              <td>Child lifecycle/render error</td>
              <td>N/A</td>
              <td>Error boundary, fallback UI</td>
              <td>Does NOT catch event handler errors</td>
            </tr>
          </tbody>
        </table>

        <h3>Parent-Child Order Summary</h3>
        <table>
          <thead>
            <tr>
              <th>Phase</th>
              <th>Order</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>constructor, connectedCallback</td>
              <td>Parent ‚Üí Child (top-down)</td>
            </tr>
            <tr>
              <td>renderedCallback</td>
              <td>Child ‚Üí Parent (bottom-up)</td>
            </tr>
            <tr>
              <td>disconnectedCallback</td>
              <td>Child ‚Üí Parent (bottom-up)</td>
            </tr>
          </tbody>
        </table>
      </section>

      <!-- References -->
      <section id="references">
        <h2>References</h2>
        <ul>
          <li>
            <a href="https://developer.salesforce.com/docs/platform/lwc/guide/create-lifecycle-hooks.html"
               target="_blank" rel="noopener noreferrer">
              Salesforce LWC Docs: Lifecycle Hooks
            </a>
          </li>
          <li>
            <a href="https://developer.salesforce.com/docs/platform/lwc/guide/reference-error-callback.html"
               target="_blank" rel="noopener noreferrer">
              Salesforce LWC Docs: errorCallback
            </a>
          </li>
          <li>
            <a href="https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements-lifecycle-examples"
               target="_blank" rel="noopener noreferrer">
              WHATWG HTML Spec: Custom Elements Lifecycle Examples
            </a>
          </li>
          <li>
            <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements"
               target="_blank" rel="noopener noreferrer">
              MDN: Using Custom Elements
            </a>
          </li>
          <li>
            <a href="https://developer.salesforce.com/docs/platform/lwc/guide/lightning-message-service.html"
               target="_blank" rel="noopener noreferrer">
              Salesforce LWC Docs: Lightning Message Service
            </a>
          </li>
          <li>
            <a href="https://developer.salesforce.com/docs/platform/lwc/guide/js-props-getter-setter.html"
               target="_blank" rel="noopener noreferrer">
              Salesforce LWC Docs: Use Getters and Setters
            </a>
          </li>
        </ul>
      </section>

      <!-- Article Nav -->
      <nav class="article-nav" aria-label="Article navigation">
        <a href="04-decorators.html" class="nav-prev">
          <span class="nav-label">‚Üê Previous</span>
          <span class="nav-title">04. Decorators: @api, @track, @wire</span>
        </a>
        <a href="06-template-directives.html" class="nav-next">
          <span class="nav-label">Next ‚Üí</span>
          <span class="nav-title">06. HTML Template Directives</span>
        </a>
      </nav>

    </main><!-- /.article-main -->
  </div><!-- /.article-page -->

  <!-- ================================================================
       SITE FOOTER
       ================================================================ -->
  <footer class="site-footer" role="contentinfo">
    <p>
      <a href="../index.html">‚Üê Back to all articles</a> ‚Ä¢
      <a href="https://developer.salesforce.com/docs/component-library/documentation/en/lwc" target="_blank" rel="noopener noreferrer">Official LWC Docs</a>
    </p>
    <p class="footer-disclaimer">
      Lightning Web Components (LWC) and Salesforce are trademarks of Salesforce, Inc.
      This site is an independent educational resource and is not affiliated with,
      endorsed by, or sponsored by Salesforce, Inc.
    </p>
    <p class="footer-copyright">&#169; 2026 Mohak Purushottam Pingle. Content licensed under MIT.</p>
  </footer>

  <!-- ================================================================
       SCRIPTS
       ================================================================ -->
  <script src="../assets/prism.min.js"></script>
  <script src="../assets/prism-javascript.min.js"></script>
  <script src="../assets/prism-markup.min.js"></script>
  <script src="../assets/prism-css.min.js"></script>
  <script src="../assets/prism-json.min.js"></script>
  <script src="../search.js"></script>

  <script>
    // ----------------------------------------------------------------
    // 1. Dark / Light Theme Toggle
    // ----------------------------------------------------------------
    (function () {
      const toggle     = document.getElementById('themeToggle');
      const themeLabel = document.getElementById('themeLabel');
      const html       = document.documentElement;

      function applyTheme(theme) {
        html.setAttribute('data-theme', theme);
        if (themeLabel) themeLabel.textContent = theme === 'dark' ? 'Light' : 'Dark';
        try { localStorage.setItem('lwc_blog_theme', theme); } catch { /* */ }
      }

      try {
        const saved = localStorage.getItem('lwc_blog_theme');
        if (saved === 'dark' || saved === 'light') applyTheme(saved);
      } catch { /* */ }

      if (toggle) {
        toggle.addEventListener('click', () => {
          const current = html.getAttribute('data-theme');
          applyTheme(current === 'dark' ? 'light' : 'dark');
        });
      }
    })();

    // ----------------------------------------------------------------
    // 2. Mark as Read
    // ----------------------------------------------------------------
    (function () {
      const btn       = document.getElementById('markReadBtn');
      const articleId = btn ? btn.getAttribute('data-article-id') : null;
      if (!btn || !articleId) return;

      const STORAGE_KEY = 'lwc_blog_read';

      function getReadSet() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          return raw ? new Set(JSON.parse(raw)) : new Set();
        } catch { return new Set(); }
      }

      function saveReadSet(set) {
        try { localStorage.setItem(STORAGE_KEY, JSON.stringify([...set])); } catch { /* */ }
      }

      function setReadState(isRead) {
        btn.textContent = isRead ? '‚úì Read' : '‚òê Mark as Read';
        btn.classList.toggle('is-read', isRead);
        btn.setAttribute('aria-pressed', isRead ? 'true' : 'false');
      }

      setReadState(getReadSet().has(articleId));

      btn.addEventListener('click', () => {
        const readSet = getReadSet();
        const isRead  = readSet.has(articleId);
        if (isRead) { readSet.delete(articleId); } else { readSet.add(articleId); }
        saveReadSet(readSet);
        setReadState(!isRead);
      });
    })();

    // ----------------------------------------------------------------
    // 3. Sticky TOC Scroll-Spy
    // ----------------------------------------------------------------
    (function () {
      const tocLinks = document.querySelectorAll('.toc-list a');
      if (!tocLinks.length) return;

      const headings = Array.from(
        document.querySelectorAll('.article-main h2[id], .article-main h3[id]')
      );
      if (!headings.length) return;

      function getActiveHeading() {
        const scrollY = window.scrollY + 120;
        let active = headings[0];
        for (const heading of headings) {
          if (heading.offsetTop <= scrollY) { active = heading; } else { break; }
        }
        return active;
      }

      function updateToc() {
        const active = getActiveHeading();
        tocLinks.forEach(link => {
          link.classList.toggle('active', link.getAttribute('href') === `#${active.id}`);
        });
      }

      let ticking = false;
      window.addEventListener('scroll', () => {
        if (!ticking) {
          requestAnimationFrame(() => { updateToc(); ticking = false; });
          ticking = true;
        }
      }, { passive: true });

      updateToc();
    })();

    // ----------------------------------------------------------------
    // 4. Collapsible Callout Boxes
    // ----------------------------------------------------------------
    (function () {
      document.querySelectorAll('.callout__header').forEach(header => {
        const body   = header.nextElementSibling;
        const toggle = header.querySelector('.callout__toggle');
        if (!body) return;

        function setExpanded(expanded) {
          body.style.display = expanded ? '' : 'none';
          header.setAttribute('aria-expanded', expanded);
          if (toggle) toggle.textContent = expanded ? '‚ñº' : '‚ñ∂';
        }

        setExpanded(true);

        header.addEventListener('click', () => {
          setExpanded(header.getAttribute('aria-expanded') === 'false');
        });

        header.addEventListener('keydown', e => {
          if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); header.click(); }
        });
      });
    })();

    // ----------------------------------------------------------------
    // 5. URL-based search init
    // ----------------------------------------------------------------
    if (window.LWCSearch && window.LWCSearch.initUrlSearch) {
      window.LWCSearch.initUrlSearch();
    }
  </script>
</body>
</html>
